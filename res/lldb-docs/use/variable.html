
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Variable Formatting &#8212; The LLDB Debugger</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/lldb.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Symbolication" href="symbolication.html" />
    <link rel="prev" title="Frame and Thread Format" href="formatting.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="variable-formatting">
<h1>Variable Formatting<a class="headerlink" href="#variable-formatting" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#type-format" id="id1">Type Format</a></p></li>
<li><p><a class="reference internal" href="#type-summary" id="id2">Type Summary</a></p></li>
<li><p><a class="reference internal" href="#summary-strings" id="id3">Summary Strings</a></p></li>
<li><p><a class="reference internal" href="#formatting-summary-elements" id="id4">Formatting Summary Elements</a></p></li>
<li><p><a class="reference internal" href="#element-inlining" id="id5">Element Inlining</a></p></li>
<li><p><a class="reference internal" href="#bitfields-and-array-syntax" id="id6">Bitfields And Array Syntax</a></p></li>
<li><p><a class="reference internal" href="#python-scripting" id="id7">Python Scripting</a></p></li>
<li><p><a class="reference internal" href="#regular-expression-typenames" id="id8">Regular Expression Typenames</a></p></li>
<li><p><a class="reference internal" href="#names-summaries" id="id9">Names Summaries</a></p></li>
<li><p><a class="reference internal" href="#synthetic-children" id="id10">Synthetic Children</a></p></li>
<li><p><a class="reference internal" href="#filters" id="id11">Filters</a></p></li>
<li><p><a class="reference internal" href="#objective-c-dynamic-type-discovery" id="id12">Objective-C Dynamic Type Discovery</a></p></li>
<li><p><a class="reference internal" href="#categories" id="id13">Categories</a></p></li>
<li><p><a class="reference internal" href="#finding-formatters-101" id="id14">Finding Formatters 101</a></p></li>
</ul>
</div>
<p>LLDB has a data formatters subsystem that allows users to define custom display
options for their variables.</p>
<p>Usually, when you type frame variable or run some expression LLDB will
automatically choose the way to display your results on a per-type basis, as in
the following example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span>
<span class="p">(</span><span class="n">uint8_t</span><span class="p">)</span> <span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span>
<span class="p">(</span><span class="n">intptr_t</span><span class="p">)</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">124752287</span>
</pre></div>
</div>
<p>However, in certain cases, you may want to associate a different style to the display for certain datatypes. To do so, you need to give hints to the debugger
as to how variables should be displayed. The LLDB type command allows you to do
just that.</p>
<p>Using it you can change your visualization to look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span>
<span class="p">(</span><span class="n">uint8_t</span><span class="p">)</span> <span class="n">x</span> <span class="o">=</span> <span class="nb">chr</span><span class="o">=</span><span class="s1">&#39;a&#39;</span> <span class="n">dec</span><span class="o">=</span><span class="mi">65</span> <span class="nb">hex</span><span class="o">=</span><span class="mh">0x41</span>
<span class="p">(</span><span class="n">intptr_t</span><span class="p">)</span> <span class="n">y</span> <span class="o">=</span> <span class="mh">0x76f919f</span>
</pre></div>
</div>
<p>There are several features related to data visualization: formats, summaries,
filters, synthetic children.</p>
<p>To reflect this, the type command has five subcommands:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="nb">format</span>
<span class="nb">type</span> <span class="n">summary</span>
<span class="nb">type</span> <span class="nb">filter</span>
<span class="nb">type</span> <span class="n">synthetic</span>
<span class="nb">type</span> <span class="n">category</span>
</pre></div>
</div>
<p>These commands are meant to bind printing options to types. When variables are
printed, LLDB will first check if custom printing options have been associated
to a variable’s type and, if so, use them instead of picking the default
choices.</p>
<p>Each of the commands (except <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">category</span></code>) has four subcommands available:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">add</span></code>: associates a new printing option to one or more types</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">delete</span></code>: deletes an existing association</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">list</span></code>: provides a listing of all associations</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">clear</span></code>: deletes all associations</p></li>
</ul>
<div class="section" id="type-format">
<h2><a class="toc-backref" href="#id1">Type Format</a><a class="headerlink" href="#type-format" title="Permalink to this headline">¶</a></h2>
<p>Type formats enable you to quickly override the default format for displaying
primitive types (the usual basic C/C++/ObjC types: int, float, char, …).</p>
<p>If for some reason you want all int variables in your program to print out as
hex, you can add a format to the int type.</p>
<p>This is done by typing</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="nb">format</span> <span class="n">add</span> <span class="o">--</span><span class="nb">format</span> <span class="nb">hex</span> <span class="nb">int</span>
</pre></div>
</div>
<p>at the LLDB command line.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">--format</span></code> (which you can shorten to -f) option accepts a <a class="reference internal" href="formatting.html"><span class="doc">format
name</span></a>. Then, you provide one or more types to which you want the
new format applied.</p>
<p>A frequent scenario is that your program has a typedef for a numeric type that
you know represents something that must be printed in a certain way. Again, you
can add a format just to that typedef by using type format add with the name
alias.</p>
<p>But things can quickly get hierarchical. Let’s say you have a situation like
the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="nb">int</span> <span class="n">A</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">A</span> <span class="n">B</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">B</span> <span class="n">C</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">C</span> <span class="n">D</span><span class="p">;</span>
</pre></div>
</div>
<p>and you want to show all A’s as hex, all C’s as byte arrays and leave the
defaults untouched for other types (albeit its contrived look, the example is
far from unrealistic in large software systems).</p>
<p>If you simply type</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="nb">format</span> <span class="n">add</span> <span class="o">-</span><span class="n">f</span> <span class="nb">hex</span> <span class="n">A</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="nb">format</span> <span class="n">add</span> <span class="o">-</span><span class="n">f</span> <span class="n">uint8_t</span><span class="p">[]</span> <span class="n">C</span>
</pre></div>
</div>
<p>values of type B will be shown as hex and values of type D as byte arrays, as in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="o">-</span><span class="n">T</span>
<span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0x00000001</span>
<span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="n">b</span> <span class="o">=</span> <span class="mh">0x00000002</span>
<span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="n">c</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0x03</span> <span class="mh">0x00</span> <span class="mh">0x00</span> <span class="mh">0x00</span><span class="p">}</span>
<span class="p">(</span><span class="n">D</span><span class="p">)</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0x04</span> <span class="mh">0x00</span> <span class="mh">0x00</span> <span class="mh">0x00</span><span class="p">}</span>
</pre></div>
</div>
<p>This is because by default LLDB cascades formats through typedef chains. In
order to avoid that you can use the option -C no to prevent cascading, thus
making the two commands required to achieve your goal:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="nb">format</span> <span class="n">add</span> <span class="o">-</span><span class="n">C</span> <span class="n">no</span> <span class="o">-</span><span class="n">f</span> <span class="nb">hex</span> <span class="n">A</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="nb">format</span> <span class="n">add</span> <span class="o">-</span><span class="n">C</span> <span class="n">no</span> <span class="o">-</span><span class="n">f</span> <span class="n">uint8_t</span><span class="p">[]</span> <span class="n">C</span>
</pre></div>
</div>
<p>which provides the desired output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="o">-</span><span class="n">T</span>
<span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0x00000001</span>
<span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="n">c</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0x03</span> <span class="mh">0x00</span> <span class="mh">0x00</span> <span class="mh">0x00</span><span class="p">}</span>
<span class="p">(</span><span class="n">D</span><span class="p">)</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">4</span>
</pre></div>
</div>
<p>Two additional options that you will want to look at are –skip-pointers (-p)
and –skip-references (-r). These two options prevent LLDB from applying a
format for type T to values of type T* and T&amp; respectively.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="nb">format</span> <span class="n">add</span> <span class="o">-</span><span class="n">f</span> <span class="n">float32</span><span class="p">[]</span> <span class="nb">int</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">pointer</span> <span class="o">*</span><span class="n">pointer</span> <span class="o">-</span><span class="n">T</span>
<span class="p">(</span><span class="nb">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">pointer</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.46991e-39</span> <span class="mf">1.4013e-45</span><span class="p">}</span>
<span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span><span class="n">pointer</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.53302e-42</span><span class="p">}</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="nb">format</span> <span class="n">add</span> <span class="o">-</span><span class="n">f</span> <span class="n">float32</span><span class="p">[]</span> <span class="nb">int</span> <span class="o">-</span><span class="n">p</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">pointer</span> <span class="o">*</span><span class="n">pointer</span> <span class="o">-</span><span class="n">T</span>
<span class="p">(</span><span class="nb">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">pointer</span> <span class="o">=</span> <span class="mh">0x0000000100100180</span>
<span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span><span class="n">pointer</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.53302e-42</span><span class="p">}</span>
</pre></div>
</div>
<p>While they can be applied to pointers and references, formats will make no
attempt to dereference the pointer and extract the value before applying the
format, which means you are effectively formatting the address stored in the
pointer rather than the pointee value. For this reason, you may want to use the
-p option when defining formats.</p>
<p>If you need to delete a custom format simply type type format delete followed
by the name of the type to which the format applies.Even if you defined the
same format for multiple types on the same command, type format delete will
only remove the format for the type name passed as argument.</p>
<p>To delete ALL formats, use <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">format</span> <span class="pre">clear</span></code>. To see all the formats
defined, use type format list.</p>
<p>If all you need to do, however, is display one variable in a custom format,
while leaving the others of the same type untouched, you can simply type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">counter</span> <span class="o">-</span><span class="n">f</span> <span class="nb">hex</span>
</pre></div>
</div>
<p>This has the effect of displaying the value of counter as an hexadecimal
number, and will keep showing it this way until you either pick a different
format or till you let your program run again.</p>
<p>Finally, this is a list of formatting options available out of which you can
pick:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 34%" />
<col style="width: 13%" />
<col style="width: 53%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Format name</strong></p></td>
<td><p><strong>Abbreviation</strong></p></td>
<td><p><strong>Description</strong></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">default</span></code></p></td>
<td></td>
<td><p>the default LLDB algorithm is used to pick a format</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">boolean</span></code></p></td>
<td><p>B</p></td>
<td><p>show this as a true/false boolean, using the customary rule that 0 is
false and everything else is true</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">binary</span></code></p></td>
<td><p>b</p></td>
<td><p>show this as a sequence of bits</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">bytes</span></code></p></td>
<td><p>y</p></td>
<td><p>show the bytes one after the other</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">bytes</span> <span class="pre">with</span> <span class="pre">ASCII</span></code></p></td>
<td><p>Y</p></td>
<td><p>show the bytes, but try to display them as ASCII characters as well</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">character</span></code></p></td>
<td><p>c</p></td>
<td><p>show the bytes as ASCII characters</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">printable</span> <span class="pre">character</span></code></p></td>
<td><p>C</p></td>
<td><p>show the bytes as printable ASCII characters</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">complex</span> <span class="pre">float</span></code></p></td>
<td><p>F</p></td>
<td><p>interpret this value as the real and imaginary part of a complex
floating-point number</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">c-string</span></code></p></td>
<td><p>s</p></td>
<td><p>show this as a 0-terminated C string</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">decimal</span></code></p></td>
<td><p>d</p></td>
<td><p>show this as a signed integer number (this does not perform a cast, it
simply shows the bytes as  an integer with sign)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">enumeration</span></code></p></td>
<td><p>E</p></td>
<td><p>show this as an enumeration, printing the
value’s name if available or the integer value otherwise</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">hex</span></code></p></td>
<td><p>x</p></td>
<td><p>show this as in hexadecimal notation (this does
not perform a cast, it simply shows the bytes as hex)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">float</span></code></p></td>
<td><p>f</p></td>
<td><p>show this as a floating-point number (this does not perform a cast, it
simply interprets the bytes as an IEEE754 floating-point value)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">octal</span></code></p></td>
<td><p>o</p></td>
<td><p>show this in octal notation</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">OSType</span></code></p></td>
<td><p>O</p></td>
<td><p>show this as a MacOS OSType</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">unicode16</span></code></p></td>
<td><p>U</p></td>
<td><p>show this as UTF-16 characters</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">unicode32</span></code></p></td>
<td></td>
<td><p>show this as UTF-32 characters</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">decimal</span></code></p></td>
<td><p>u</p></td>
<td><p>show this as an unsigned integer number (this does not perform a cast,
it simply shows the bytes as unsigned integer)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">pointer</span></code></p></td>
<td><p>p</p></td>
<td><p>show this as a native pointer (unless this is really a pointer, the
resulting address will probably be invalid)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">char[]</span></code></p></td>
<td></td>
<td><p>show this as an array of characters</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">int8_t[],</span> <span class="pre">uint8_t[]</span></code>
<code class="docutils literal notranslate"><span class="pre">int16_t[],</span> <span class="pre">uint16_t[]</span></code>
<code class="docutils literal notranslate"><span class="pre">int32_t[],</span> <span class="pre">uint32_t[]</span></code>
<code class="docutils literal notranslate"><span class="pre">int64_t[],</span> <span class="pre">uint64_t[]</span></code>
<code class="docutils literal notranslate"><span class="pre">uint128_t[]</span></code></p></td>
<td></td>
<td><p>show this as an array of the corresponding integer type</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">float32[],</span> <span class="pre">float64[]</span></code></p></td>
<td></td>
<td><dl class="simple">
<dt>show this as an array of the corresponding</dt><dd><p>floating-point type</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">complex</span> <span class="pre">integer</span></code></p></td>
<td><p>I</p></td>
<td><p>interpret this value as the real and imaginary part of a complex integer
number</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">character</span> <span class="pre">array</span></code></p></td>
<td><p>a</p></td>
<td><p>show this as a character array</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">address</span></code></p></td>
<td><p>A</p></td>
<td><p>show this as an address target (symbol/file/line + offset), possibly
also the string this address is pointing to</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">hex</span> <span class="pre">float</span></code></p></td>
<td></td>
<td><p>show this as hexadecimal floating point</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">instruction</span></code></p></td>
<td><p>i</p></td>
<td><p>show this as an disassembled opcode</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">void</span></code></p></td>
<td><p>v</p></td>
<td><p>don’t show anything</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="type-summary">
<h2><a class="toc-backref" href="#id2">Type Summary</a><a class="headerlink" href="#type-summary" title="Permalink to this headline">¶</a></h2>
<p>Type formats work by showing a different kind of display for the value of a
variable. However, they only work for basic types. When you want to display a
class or struct in a custom format, you cannot do that using formats.</p>
<p>A different feature, type summaries, works by extracting information from
classes, structures, … (aggregate types) and arranging it in a user-defined
format, as in the following example:</p>
<p>before adding a summary…</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="o">-</span><span class="n">T</span> <span class="n">one</span>
<span class="p">(</span><span class="n">i_am_cool</span><span class="p">)</span> <span class="n">one</span> <span class="o">=</span> <span class="p">{</span>
   <span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>
   <span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">3.14159</span>
   <span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="n">z</span> <span class="o">=</span> <span class="s1">&#39;E&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>after adding a summary…</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">one</span>
<span class="p">(</span><span class="n">i_am_cool</span><span class="p">)</span> <span class="n">one</span> <span class="o">=</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3.14159</span><span class="p">,</span> <span class="n">char</span> <span class="o">=</span> <span class="mi">69</span>
</pre></div>
</div>
<p>There are two ways to use type summaries: the first one is to bind a summary
string to the type; the second is to write a Python script that returns the
string to be used as summary. Both options are enabled by the type summary add
command.</p>
<p>The command to obtain the output shown in the example is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="o">--</span><span class="n">summary</span><span class="o">-</span><span class="n">string</span> <span class="s2">&quot;int = $</span><span class="si">{var.x}</span><span class="s2">, float = $</span><span class="si">{var.y}</span><span class="s2">, char = ${var.z</span><span class="si">%u</span><span class="s2">}&quot;</span> <span class="n">i_am_cool</span>
</pre></div>
</div>
<p>Initially, we will focus on summary strings, and then describe the Python
binding mechanism.</p>
</div>
<div class="section" id="summary-strings">
<h2><a class="toc-backref" href="#id3">Summary Strings</a><a class="headerlink" href="#summary-strings" title="Permalink to this headline">¶</a></h2>
<p>Summary strings are written using a simple control language, exemplified by the
snippet above. A summary string contains a sequence of tokens that are
processed by LLDB to generate the summary.</p>
<p>Summary strings can contain plain text, control characters and special
variables that have access to information about the current object and the
overall program state.</p>
<p>Plain text is any sequence of characters that doesn’t contain a <code class="docutils literal notranslate"><span class="pre">{</span></code>, <code class="docutils literal notranslate"><span class="pre">}</span></code>, <code class="docutils literal notranslate"><span class="pre">$</span></code>,
or <code class="docutils literal notranslate"><span class="pre">\</span></code> character, which are the syntax control characters.</p>
<p>The special variables are found in between a “${” prefix, and end with a “}”
suffix. Variables can be a simple name or they can refer to complex objects
that have subitems themselves. In other words, a variable looks like
<code class="docutils literal notranslate"><span class="pre">${object}</span></code> or <code class="docutils literal notranslate"><span class="pre">${object.child.otherchild}</span></code>. A variable can also be
prefixed or suffixed with other symbols meant to change the way its value is
handled. An example is <code class="docutils literal notranslate"><span class="pre">${*var.int_pointer[0-3]}</span></code>.</p>
<p>Basically, the syntax is the same one described Frame and Thread Formatting
plus additional symbols specific for summary strings. The main of them is
${var, which is used refer to the variable that a summary is being created for.</p>
<p>The simplest thing you can do is grab a member variable of a class or structure
by typing its expression path. In the previous example, the expression path for
the field float y is simply .y. Thus, to ask the summary string to display y
you would type ${var.y}.</p>
<p>If you have code like the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">A</span> <span class="p">{</span>
   <span class="nb">int</span> <span class="n">x</span><span class="p">;</span>
   <span class="nb">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">struct</span> <span class="n">B</span> <span class="p">{</span>
   <span class="n">A</span> <span class="n">x</span><span class="p">;</span>
   <span class="n">A</span> <span class="n">y</span><span class="p">;</span>
   <span class="nb">int</span> <span class="o">*</span><span class="n">z</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>the expression path for the y member of the x member of an object of type B
would be .x.y and you would type <code class="docutils literal notranslate"><span class="pre">${var.x.y}</span></code> to display it in a summary
string for type B.</p>
<p>By default, a summary defined for type T, also works for types T* and T&amp; (you
can disable this behavior if desired). For this reason, expression paths do not
differentiate between . and -&gt;, and the above expression path .x.y would be
just as good if you were displaying a B*, or even if the actual definition of B
were:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">B</span> <span class="p">{</span>
   <span class="n">A</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span>
   <span class="n">A</span> <span class="n">y</span><span class="p">;</span>
   <span class="nb">int</span> <span class="o">*</span><span class="n">z</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This is unlike the behavior of frame variable which, on the contrary, will
enforce the distinction. As hinted above, the rationale for this choice is that
waiving this distinction enables you to write a summary string once for type T
and use it for both T and T* instances. As a summary string is mostly about
extracting nested members’ information, a pointer to an object is just as good
as the object itself for the purpose.</p>
<p>If you need to access the value of the integer pointed to by B::z, you cannot
simply say ${var.z} because that symbol refers to the pointer z. In order to
dereference it and get the pointed value, you should say <code class="docutils literal notranslate"><span class="pre">${*var.z}</span></code>. The
<code class="docutils literal notranslate"><span class="pre">${*var</span></code> tells LLDB to get the object that the expression paths leads to, and
then dereference it. In this example is it equivalent to <code class="docutils literal notranslate"><span class="pre">*(bObject.z)</span></code> in
C/C++ syntax. Because . and -&gt; operators can both be used, there is no need to
have dereferences in the middle of an expression path (e.g. you do not need to
type <code class="docutils literal notranslate"><span class="pre">${*(var.x).x}</span></code>) to read A::x as contained in <code class="docutils literal notranslate"><span class="pre">*(B::x)</span></code>. To achieve
that effect you can simply write <code class="docutils literal notranslate"><span class="pre">${var.x-&gt;x}</span></code>, or even <code class="docutils literal notranslate"><span class="pre">${var.x.x}</span></code>. The
<code class="docutils literal notranslate"><span class="pre">*</span></code> operator only binds to the result of the whole expression path, rather
than piecewise, and there is no way to use parentheses to change that behavior.</p>
<p>Of course, a summary string can contain more than one ${var specifier, and can
use <code class="docutils literal notranslate"><span class="pre">${var</span></code> and <code class="docutils literal notranslate"><span class="pre">${*var</span></code> specifiers together.</p>
</div>
<div class="section" id="formatting-summary-elements">
<h2><a class="toc-backref" href="#id4">Formatting Summary Elements</a><a class="headerlink" href="#formatting-summary-elements" title="Permalink to this headline">¶</a></h2>
<p>An expression path can include formatting codes. Much like the type formats
discussed previously, you can also customize the way variables are displayed in
summary strings, regardless of the format they have applied to their types. To
do that, you can use %format inside an expression path, as in ${var.x-&gt;x%u},
which would display the value of x as an unsigned integer.</p>
<p>You can also use some other special format markers, not available for formats
themselves, but which carry a special meaning when used in this context:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 86%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Symbol</strong></p></td>
<td><p><strong>Description</strong></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">Symbol</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Description</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%S</span></code></p></td>
<td><p>Use this object’s summary (the default for aggregate types)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%V</span></code></p></td>
<td><p>Use this object’s value (the default for non-aggregate types)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%&#64;</span></code></p></td>
<td><dl class="simple">
<dt>Use a language-runtime specific description (for C++ this does nothing,</dt><dd><p>for Objective-C it calls the NSPrintForDebugger API)</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%L</span></code></p></td>
<td><p>Use this object’s location (memory address, register name, …)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%#</span></code></p></td>
<td><p>Use the count of the children of this object</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%T</span></code></p></td>
<td><p>Use this object’s datatype name</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%N</span></code></p></td>
<td><p>Print the variable’s basename</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%&gt;</span></code></p></td>
<td><p>Print the expression path for this item</p></td>
</tr>
</tbody>
</table>
<p>Starting with SVN r228207, you can also specify
<code class="docutils literal notranslate"><span class="pre">${script.var:pythonFuncName}</span></code>. Previously, back to r220821, this was
specified with a different syntax: <code class="docutils literal notranslate"><span class="pre">${var.script:pythonFuncName}</span></code>.</p>
<p>It is expected that the function name you use specifies a function whose
signature is the same as a Python summary function. The return string from the
function will be placed verbatim in the output.</p>
<p>You cannot use element access, or formatting symbols, in combination with this
syntax. For example the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>${script.var.element[0]:myFunctionName%@}
</pre></div>
</div>
<p>is not valid and will cause the summary to fail to evaluate.</p>
</div>
<div class="section" id="element-inlining">
<h2><a class="toc-backref" href="#id5">Element Inlining</a><a class="headerlink" href="#element-inlining" title="Permalink to this headline">¶</a></h2>
<p>Option –inline-children (-c) to type summary add tells LLDB not to look for a summary string, but instead to just print a listing of all the object’s children on one line.</p>
<p>As an example, given a type pair:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="o">--</span><span class="n">show</span><span class="o">-</span><span class="n">types</span> <span class="n">a_pair</span>
<span class="p">(</span><span class="n">pair</span><span class="p">)</span> <span class="n">a_pair</span> <span class="o">=</span> <span class="p">{</span>
   <span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="n">first</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="n">second</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If one types the following commands:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="o">--</span><span class="n">inline</span><span class="o">-</span><span class="n">children</span> <span class="n">pair</span>
</pre></div>
</div>
<p>the output becomes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">a_pair</span>
<span class="p">(</span><span class="n">pair</span><span class="p">)</span> <span class="n">a_pair</span> <span class="o">=</span> <span class="p">(</span><span class="n">first</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">second</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Of course, one can obtain the same effect by typing</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="n">pair</span> <span class="o">--</span><span class="n">summary</span><span class="o">-</span><span class="n">string</span> <span class="s2">&quot;(first=$</span><span class="si">{var.first}</span><span class="s2">, second=$</span><span class="si">{var.second}</span><span class="s2">)&quot;</span>
</pre></div>
</div>
<p>While the final result is the same, using –inline-children can often save
time. If one does not need to see the names of the variables, but just their
values, the option –omit-names (-O, uppercase letter o), can be combined with
–inline-children to obtain:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">a_pair</span>
<span class="p">(</span><span class="n">pair</span><span class="p">)</span> <span class="n">a_pair</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>which is of course the same as typing</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="n">pair</span> <span class="o">--</span><span class="n">summary</span><span class="o">-</span><span class="n">string</span> <span class="s2">&quot;($</span><span class="si">{var.first}</span><span class="s2">, $</span><span class="si">{var.second}</span><span class="s2">)&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="bitfields-and-array-syntax">
<h2><a class="toc-backref" href="#id6">Bitfields And Array Syntax</a><a class="headerlink" href="#bitfields-and-array-syntax" title="Permalink to this headline">¶</a></h2>
<p>Sometimes, a basic type’s value actually represents several different values
packed together in a bitfield.</p>
<p>With the classical view, there is no way to look at them. Hexadecimal display
can help, but if the bits actually span nibble boundaries, the help is limited.</p>
<p>Binary view would show it all without ambiguity, but is often too detailed and
hard to read for real-life scenarios.</p>
<p>To cope with the issue, LLDB supports native bitfield formatting in summary
strings. If your expression paths leads to a so-called scalar type (the usual
int, float, char, double, short, long, long long, double, long double and
unsigned variants), you can ask LLDB to only grab some bits out of the value
and display them in any format you like. If you only need one bit you can use
the [n], just like indexing an array. To extract multiple bits, you can use a
slice-like syntax: [n-m], e.g.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">float_point</span>
<span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="n">float_point</span> <span class="o">=</span> <span class="o">-</span><span class="mf">3.14159</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="o">--</span><span class="n">summary</span><span class="o">-</span><span class="n">string</span> <span class="s2">&quot;Sign: ${var[31]%B} Exponent: ${var[30-23]</span><span class="si">%x</span><span class="s2">} Mantissa: ${var[0-22]</span><span class="si">%u</span><span class="s2">}&quot;</span> <span class="nb">float</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">float_point</span>
<span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="n">float_point</span> <span class="o">=</span> <span class="o">-</span><span class="mf">3.14159</span> <span class="n">Sign</span><span class="p">:</span> <span class="n">true</span> <span class="n">Exponent</span><span class="p">:</span> <span class="mh">0x00000080</span> <span class="n">Mantissa</span><span class="p">:</span> <span class="mi">4788184</span>
</pre></div>
</div>
<p>In this example, LLDB shows the internal representation of a float variable by
extracting bitfields out of a float object.</p>
<p>When typing a range, the extremes n and m are always included, and the order of
the indices is irrelevant.</p>
<p>LLDB also allows to use a similar syntax to display array members inside a summary string. For instance, you may want to display all arrays of a given type using a more compact notation than the default, and then just delve into individual array members that prove interesting to your debugging task. You can tell LLDB to format arrays in special ways, possibly independent of the way the array members’ datatype is formatted.
e.g.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">sarray</span>
<span class="p">(</span><span class="n">Simple</span> <span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="n">sarray</span> <span class="o">=</span> <span class="p">{</span>
   <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
      <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span>
      <span class="n">z</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\x03</span><span class="s1">&#39;</span>
   <span class="p">}</span>
   <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
      <span class="n">x</span> <span class="o">=</span> <span class="mi">4</span>
      <span class="n">y</span> <span class="o">=</span> <span class="mi">5</span>
      <span class="n">z</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\x06</span><span class="s1">&#39;</span>
   <span class="p">}</span>
   <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
      <span class="n">x</span> <span class="o">=</span> <span class="mi">7</span>
      <span class="n">y</span> <span class="o">=</span> <span class="mi">8</span>
      <span class="n">z</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="o">--</span><span class="n">summary</span><span class="o">-</span><span class="n">string</span> <span class="s2">&quot;${var[].x}&quot;</span> <span class="s2">&quot;Simple [3]&quot;</span>

<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">sarray</span>
<span class="p">(</span><span class="n">Simple</span> <span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="n">sarray</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
</pre></div>
</div>
<p>The [] symbol amounts to: if var is an array and I know its size, apply this summary string to every element of the array. Here, we are asking LLDB to display .x for every element of the array, and in fact this is what happens. If you find some of those integers anomalous, you can then inspect that one item in greater detail, without the array format getting in the way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">sarray</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">(</span><span class="n">Simple</span><span class="p">)</span> <span class="n">sarray</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
   <span class="n">x</span> <span class="o">=</span> <span class="mi">4</span>
   <span class="n">y</span> <span class="o">=</span> <span class="mi">5</span>
   <span class="n">z</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\x06</span><span class="s1">&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You can also ask LLDB to only print a subset of the array range by using the
same syntax used to extract bit for bitfields:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="o">--</span><span class="n">summary</span><span class="o">-</span><span class="n">string</span> <span class="s2">&quot;$</span><span class="si">{var[1-2].x}</span><span class="s2">&quot;</span> <span class="s2">&quot;Simple [3]&quot;</span>

<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">sarray</span>
<span class="p">(</span><span class="n">Simple</span> <span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="n">sarray</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
</pre></div>
</div>
<p>If you are dealing with a pointer that you know is an array, you can use this
syntax to display the elements contained in the pointed array instead of just
the pointer value. However, because pointers have no notion of their size, the
empty brackets [] operator does not work, and you must explicitly provide
higher and lower bounds.</p>
<p>In general, LLDB needs the square brackets operator [] in order to handle
arrays and pointers correctly, and for pointers it also needs a range. However,
a few special cases are defined to make your life easier:</p>
<p>you can print a 0-terminated string (C-string) using the %s format, omitting
square brackets, as in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="o">--</span><span class="n">summary</span><span class="o">-</span><span class="n">string</span> <span class="s2">&quot;${var</span><span class="si">%s</span><span class="s2">}&quot;</span> <span class="s2">&quot;char *&quot;</span>
</pre></div>
</div>
<p>This syntax works for char* as well as for char[] because LLDB can rely on the
final 0 terminator to know when the string has ended.</p>
<p>LLDB has default summary strings for char* and char[] that use this special
case. On debugger startup, the following are defined automatically:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="o">--</span><span class="n">summary</span><span class="o">-</span><span class="n">string</span> <span class="s2">&quot;${var</span><span class="si">%s</span><span class="s2">}&quot;</span> <span class="s2">&quot;char *&quot;</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="o">--</span><span class="n">summary</span><span class="o">-</span><span class="n">string</span> <span class="s2">&quot;${var</span><span class="si">%s</span><span class="s2">}&quot;</span> <span class="o">-</span><span class="n">x</span> <span class="s2">&quot;char \[[0-9]+]&quot;</span>
</pre></div>
</div>
<p>any of the array formats (int8_t[], float32{}, …), and the y, Y and a formats
work to print an array of a non-aggregate type, even if square brackets are
omitted.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="o">--</span><span class="n">summary</span><span class="o">-</span><span class="n">string</span> <span class="s2">&quot;${var</span><span class="si">%i</span><span class="s2">nt32_t[]}&quot;</span> <span class="s2">&quot;int [10]&quot;</span>
</pre></div>
</div>
<p>This feature, however, is not enabled for pointers because there is no way for
LLDB to detect the end of the pointed data.</p>
<p>This also does not work for other formats (e.g. boolean), and you must specify
the square brackets operator to get the expected output.</p>
</div>
<div class="section" id="python-scripting">
<h2><a class="toc-backref" href="#id7">Python Scripting</a><a class="headerlink" href="#python-scripting" title="Permalink to this headline">¶</a></h2>
<p>Most of the times, summary strings prove good enough for the job of summarizing
the contents of a variable. However, as soon as you need to do more than
picking some values and rearranging them for display, summary strings stop
being an effective tool. This is because summary strings lack the power to
actually perform any kind of computation on the value of variables.</p>
<p>To solve this issue, you can bind some Python scripting code as a summary for
your datatype, and that script has the ability to both extract children
variables as the summary strings do and to perform active computation on the
extracted values. As a small example, let’s say we have a Rectangle class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rectangle</span>
<span class="p">{</span>
<span class="n">private</span><span class="p">:</span>
   <span class="nb">int</span> <span class="n">height</span><span class="p">;</span>
   <span class="nb">int</span> <span class="n">width</span><span class="p">;</span>
<span class="n">public</span><span class="p">:</span>
   <span class="n">Rectangle</span><span class="p">()</span> <span class="p">:</span> <span class="n">height</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">width</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">{}</span>
   <span class="n">Rectangle</span><span class="p">(</span><span class="nb">int</span> <span class="n">H</span><span class="p">)</span> <span class="p">:</span> <span class="n">height</span><span class="p">(</span><span class="n">H</span><span class="p">),</span> <span class="n">width</span><span class="p">(</span><span class="n">H</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{}</span>
   <span class="n">Rectangle</span><span class="p">(</span><span class="nb">int</span> <span class="n">H</span><span class="p">,</span> <span class="nb">int</span> <span class="n">W</span><span class="p">)</span> <span class="p">:</span> <span class="n">height</span><span class="p">(</span><span class="n">H</span><span class="p">),</span> <span class="n">width</span><span class="p">(</span><span class="n">W</span><span class="p">)</span> <span class="p">{}</span>
   <span class="nb">int</span> <span class="n">GetHeight</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">height</span><span class="p">;</span> <span class="p">}</span>
   <span class="nb">int</span> <span class="n">GetWidth</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">width</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Summary strings are effective to reduce the screen real estate used by the
default viewing mode, but are not effective if we want to display the area and
perimeter of Rectangle objects</p>
<p>To obtain this, we can simply attach a small Python script to the Rectangle
class, as shown in this example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="o">-</span><span class="n">P</span> <span class="n">Rectangle</span>
<span class="n">Enter</span> <span class="n">your</span> <span class="n">Python</span> <span class="n">command</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span> <span class="n">Type</span> <span class="s1">&#39;DONE&#39;</span> <span class="n">to</span> <span class="n">end</span><span class="o">.</span>
<span class="k">def</span> <span class="nf">function</span> <span class="p">(</span><span class="n">valobj</span><span class="p">,</span><span class="n">internal_dict</span><span class="p">):</span>
   <span class="n">height_val</span> <span class="o">=</span> <span class="n">valobj</span><span class="o">.</span><span class="n">GetChildMemberWithName</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">)</span>
   <span class="n">width_val</span> <span class="o">=</span> <span class="n">valobj</span><span class="o">.</span><span class="n">GetChildMemberWithName</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">)</span>
   <span class="n">height</span> <span class="o">=</span> <span class="n">height_val</span><span class="o">.</span><span class="n">GetValueAsUnsigned</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
   <span class="n">width</span> <span class="o">=</span> <span class="n">width_val</span><span class="o">.</span><span class="n">GetValueAsUnsigned</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
   <span class="n">area</span> <span class="o">=</span> <span class="n">height</span><span class="o">*</span><span class="n">width</span>
   <span class="n">perimeter</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">height</span> <span class="o">+</span> <span class="n">width</span><span class="p">)</span>
   <span class="k">return</span> <span class="s1">&#39;Area: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">area</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;, Perimeter: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">perimeter</span><span class="p">)</span>
   <span class="n">DONE</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span>
<span class="p">(</span><span class="n">Rectangle</span><span class="p">)</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">Area</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="n">Perimeter</span><span class="p">:</span> <span class="mi">18</span>
<span class="p">(</span><span class="n">Rectangle</span><span class="p">)</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">Area</span><span class="p">:</span> <span class="mi">72</span><span class="p">,</span> <span class="n">Perimeter</span><span class="p">:</span> <span class="mi">36</span>
<span class="p">(</span><span class="n">Rectangle</span><span class="p">)</span> <span class="n">r3</span> <span class="o">=</span> <span class="n">Area</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span> <span class="n">Perimeter</span><span class="p">:</span> <span class="mi">16</span>
</pre></div>
</div>
<p>In order to write effective summary scripts, you need to know the LLDB public
API, which is the way Python code can access the LLDB object model. For further
details on the API you should look at the LLDB API reference documentation.</p>
<p>As a brief introduction, your script is encapsulated into a function that is
passed two parameters: <code class="docutils literal notranslate"><span class="pre">valobj</span></code> and <code class="docutils literal notranslate"><span class="pre">internal_dict</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">internal_dict</span></code> is an internal support parameter used by LLDB and you should
not touch it.</p>
<p><code class="docutils literal notranslate"><span class="pre">valobj</span></code> is the object encapsulating the actual variable being displayed, and
its type is SBValue. Out of the many possible operations on an SBValue, the
basic one is retrieve the children objects it contains (essentially, the fields
of the object wrapped by it), by calling <code class="docutils literal notranslate"><span class="pre">GetChildMemberWithName()</span></code>, passing
it the child’s name as a string.</p>
<p>If the variable has a value, you can ask for it, and return it as a string
using <code class="docutils literal notranslate"><span class="pre">GetValue()</span></code>, or as a signed/unsigned number using
<code class="docutils literal notranslate"><span class="pre">GetValueAsSigned()</span></code>, <code class="docutils literal notranslate"><span class="pre">GetValueAsUnsigned()</span></code>. It is also possible to
retrieve an SBData object by calling <code class="docutils literal notranslate"><span class="pre">GetData()</span></code> and then read the object’s
contents out of the SBData.</p>
<p>If you need to delve into several levels of hierarchy, as you can do with
summary strings, you can use the method <code class="docutils literal notranslate"><span class="pre">GetValueForExpressionPath()</span></code>,
passing it an expression path just like those you could use for summary strings
(one of the differences is that dereferencing a pointer does not occur by
prefixing the path with a <code class="docutils literal notranslate"><span class="pre">*`</span></code>, but by calling the <code class="docutils literal notranslate"><span class="pre">Dereference()</span></code> method
on the returned SBValue). If you need to access array slices, you cannot do
that (yet) via this method call, and you must use <code class="docutils literal notranslate"><span class="pre">GetChildAtIndex()</span></code>
querying it for the array items one by one. Also, handling custom formats is
something you have to deal with on your own.</p>
<p>Other than interactively typing a Python script there are two other ways for
you to input a Python script as a summary:</p>
<ul class="simple">
<li><p>using the –python-script option to type summary add and typing the script
code as an option argument; as in:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="o">--</span><span class="n">python</span><span class="o">-</span><span class="n">script</span> <span class="s2">&quot;height = valobj.GetChildMemberWithName(&#39;height&#39;).GetValueAsUnsigned(0);width = valobj.GetChildMemberWithName(&#39;width&#39;).GetValueAsUnsigned(0); return &#39;Area: </span><span class="si">%d</span><span class="s2">&#39; % (height*width)&quot;</span> <span class="n">Rectangle</span>
</pre></div>
</div>
<ul class="simple">
<li><p>using the –python-function (-F) option to type summary add and giving the
name of a Python function with the correct prototype. Most probably, you will
define (or have already defined) the function in the interactive interpreter,
or somehow loaded it from a file, using the command script import command.
LLDB will emit a warning if it is unable to find the function you passed, but
will still register the binding.</p></li>
</ul>
<p>Starting in SVN r222593, Python summary formatters can optionally define a
third argument: options</p>
<p>This is an object of type <code class="docutils literal notranslate"><span class="pre">lldb.SBTypeSummaryOptions</span></code> that can be passed into
the formatter, allowing for a few customizations of the result. The decision to
adopt or not this third argument - and the meaning of options thereof - is
within the individual formatters’ writer.</p>
</div>
<div class="section" id="regular-expression-typenames">
<h2><a class="toc-backref" href="#id8">Regular Expression Typenames</a><a class="headerlink" href="#regular-expression-typenames" title="Permalink to this headline">¶</a></h2>
<p>As you noticed, in order to associate the custom summary string to the array
types, one must give the array size as part of the typename. This can long
become tiresome when using arrays of different sizes, Simple [3], Simple [9],
Simple [12], …</p>
<p>If you use the -x option, type names are treated as regular expressions instead
of type names. This would let you rephrase the above example for arrays of type
Simple [3] as:</p>
<dl class="simple">
<dt>::</dt><dd><p>(lldb) type summary add –summary-string “${var[].x}” -x “Simple [[0-9]+]”
(lldb) frame variable
(Simple [3]) sarray = [1,4,7]
(Simple [2]) sother = [3,6]</p>
</dd>
</dl>
<p>The above scenario works for Simple [3] as well as for any other array of
Simple objects.</p>
<p>While this feature is mostly useful for arrays, you could also use regular
expressions to catch other type sets grouped by name. However, as regular
expression matching is slower than normal name matching, LLDB will first try to
match by name in any way it can, and only when this fails, will it resort to
regular expression matching.</p>
<p>One of the ways LLDB uses this feature internally, is to match the names of STL
container classes, regardless of the template arguments provided. The details
for this are found at FormatManager.cpp</p>
<p>The regular expression language used by LLDB is the POSIX extended language, as
defined by the Single UNIX Specification, of which macOS is a compliant
implementation.</p>
</div>
<div class="section" id="names-summaries">
<h2><a class="toc-backref" href="#id9">Names Summaries</a><a class="headerlink" href="#names-summaries" title="Permalink to this headline">¶</a></h2>
<p>For a given type, there may be different meaningful summary representations.
However, currently, only one summary can be associated to a type at each
moment. If you need to temporarily override the association for a variable,
without changing the summary string for to its type, you can use named
summaries.</p>
<p>Named summaries work by attaching a name to a summary when creating it. Then,
when there is a need to attach the summary to a variable, the frame variable
command, supports a –summary option that tells LLDB to use the named summary
given instead of the default one.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="o">--</span><span class="n">summary</span><span class="o">-</span><span class="n">string</span> <span class="s2">&quot;x=$</span><span class="si">{var.integer}</span><span class="s2">&quot;</span> <span class="o">--</span><span class="n">name</span> <span class="n">NamedSummary</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">one</span>
<span class="p">(</span><span class="n">i_am_cool</span><span class="p">)</span> <span class="n">one</span> <span class="o">=</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3.14159</span><span class="p">,</span> <span class="n">char</span> <span class="o">=</span> <span class="mi">69</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">one</span> <span class="o">--</span><span class="n">summary</span> <span class="n">NamedSummary</span>
<span class="p">(</span><span class="n">i_am_cool</span><span class="p">)</span> <span class="n">one</span> <span class="o">=</span> <span class="n">x</span><span class="o">=</span><span class="mi">3</span>
</pre></div>
</div>
<p>When defining a named summary, binding it to one or more types becomes
optional. Even if you bind the named summary to a type, and later change the
summary string for that type, the named summary will not be changed by that.
You can delete named summaries by using the type summary delete command, as if
the summary name was the datatype that the summary is applied to</p>
<p>A summary attached to a variable using the –summary option, has the same
semantics that a custom format attached using the -f option has: it stays
attached till you attach a new one, or till you let your program run again.</p>
</div>
<div class="section" id="synthetic-children">
<h2><a class="toc-backref" href="#id10">Synthetic Children</a><a class="headerlink" href="#synthetic-children" title="Permalink to this headline">¶</a></h2>
<p>Summaries work well when one is able to navigate through an expression path. In
order for LLDB to do so, appropriate debugging information must be available.</p>
<p>Some types are opaque, i.e. no knowledge of their internals is provided. When
that’s the case, expression paths do not work correctly.</p>
<p>In other cases, the internals are available to use in expression paths, but
they do not provide a user-friendly representation of the object’s value.</p>
<p>For instance, consider an STL vector, as implemented by the GNU C++ Library:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">numbers</span> <span class="o">-</span><span class="n">T</span>
<span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span> <span class="n">numbers</span> <span class="o">=</span> <span class="p">{</span>
   <span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">_Vector_base</span><span class="o">&lt;</span><span class="nb">int</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">)</span> <span class="n">std</span><span class="p">::</span><span class="n">_Vector_base</span><span class="o">&lt;</span><span class="nb">int</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">_Vector_base</span><span class="o">&lt;</span><span class="nb">int</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">allocator</span><span class="o">&amp;</span><span class="n">tl</span><span class="p">;</span><span class="nb">int</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">::</span><span class="n">_Vector_impl</span><span class="p">)</span> <span class="n">_M_impl</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">(</span><span class="nb">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">_M_start</span> <span class="o">=</span> <span class="mh">0x00000001001008a0</span>
            <span class="p">(</span><span class="nb">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">_M_finish</span> <span class="o">=</span> <span class="mh">0x00000001001008a8</span>
            <span class="p">(</span><span class="nb">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">_M_end_of_storage</span> <span class="o">=</span> <span class="mh">0x00000001001008a8</span>
      <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, you can see how the type is implemented, and you can write a summary for
that implementation but that is not going to help you infer what items are
actually stored in the vector.</p>
<p>What you would like to see is probably something like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">numbers</span> <span class="o">-</span><span class="n">T</span>
<span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span> <span class="n">numbers</span> <span class="o">=</span> <span class="p">{</span>
   <span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
   <span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span>
   <span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">123</span>
   <span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1234</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Synthetic children are a way to get that result.</p>
<p>The feature is based upon the idea of providing a new set of children for a
variable that replaces the ones available by default through the debug
information. In the example, we can use synthetic children to provide the
vector items as children for the std::vector object.</p>
<p>In order to create synthetic children, you need to provide a Python class that
adheres to a given interface (the word is italicized because Python has no
explicit notion of interface, by that word we mean a given set of methods must
be implemented by the Python class):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SyntheticChildrenProvider</span><span class="p">:</span>
   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">valobj</span><span class="p">,</span> <span class="n">internal_dict</span><span class="p">):</span>
      <span class="n">this</span> <span class="n">call</span> <span class="n">should</span> <span class="n">initialize</span> <span class="n">the</span> <span class="n">Python</span> <span class="nb">object</span> <span class="n">using</span> <span class="n">valobj</span> <span class="k">as</span> <span class="n">the</span> <span class="n">variable</span> <span class="n">to</span> <span class="n">provide</span> <span class="n">synthetic</span> <span class="n">children</span> <span class="k">for</span>
   <span class="k">def</span> <span class="nf">num_children</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="n">this</span> <span class="n">call</span> <span class="n">should</span> <span class="k">return</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">children</span> <span class="n">that</span> <span class="n">you</span> <span class="n">want</span> <span class="n">your</span> <span class="nb">object</span> <span class="n">to</span> <span class="n">have</span>
   <span class="k">def</span> <span class="nf">get_child_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">):</span>
      <span class="n">this</span> <span class="n">call</span> <span class="n">should</span> <span class="k">return</span> <span class="n">the</span> <span class="n">index</span> <span class="n">of</span> <span class="n">the</span> <span class="n">synthetic</span> <span class="n">child</span> <span class="n">whose</span> <span class="n">name</span> <span class="ow">is</span> <span class="n">given</span> <span class="k">as</span> <span class="n">argument</span>
   <span class="k">def</span> <span class="nf">get_child_at_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">index</span><span class="p">):</span>
      <span class="n">this</span> <span class="n">call</span> <span class="n">should</span> <span class="k">return</span> <span class="n">a</span> <span class="n">new</span> <span class="n">LLDB</span> <span class="n">SBValue</span> <span class="nb">object</span> <span class="n">representing</span> <span class="n">the</span> <span class="n">child</span> <span class="n">at</span> <span class="n">the</span> <span class="n">index</span> <span class="n">given</span> <span class="k">as</span> <span class="n">argument</span>
   <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="n">this</span> <span class="n">call</span> <span class="n">should</span> <span class="n">be</span> <span class="n">used</span> <span class="n">to</span> <span class="n">update</span> <span class="n">the</span> <span class="n">internal</span> <span class="n">state</span> <span class="n">of</span> <span class="n">this</span> <span class="n">Python</span> <span class="nb">object</span> <span class="n">whenever</span> <span class="n">the</span> <span class="n">state</span> <span class="n">of</span> <span class="n">the</span> <span class="n">variables</span> <span class="ow">in</span> <span class="n">LLDB</span> <span class="n">changes</span><span class="o">.</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
   <span class="k">def</span> <span class="nf">has_children</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="n">this</span> <span class="n">call</span> <span class="n">should</span> <span class="k">return</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">this</span> <span class="nb">object</span> <span class="n">might</span> <span class="n">have</span> <span class="n">children</span><span class="p">,</span> <span class="ow">and</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">this</span> <span class="nb">object</span> <span class="n">can</span> <span class="n">be</span> <span class="n">guaranteed</span> <span class="ow">not</span> <span class="n">to</span> <span class="n">have</span> <span class="n">children</span><span class="o">.</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
   <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="n">this</span> <span class="n">call</span> <span class="n">can</span> <span class="k">return</span> <span class="n">an</span> <span class="n">SBValue</span> <span class="n">to</span> <span class="n">be</span> <span class="n">presented</span> <span class="k">as</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> <span class="n">the</span> <span class="n">synthetic</span> <span class="n">value</span> <span class="n">under</span> <span class="n">consideration</span><span class="o">.</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>[1] This method is optional. Also, it may optionally choose to return a value
(starting with SVN rev153061/LLDB-134). If it returns a value, and that value
is True, LLDB will be allowed to cache the children and the children count it
previously obtained, and will not return to the provider class to ask. If
nothing, None, or anything other than True is returned, LLDB will discard the
cached information and ask. Regardless, whenever necessary LLDB will call
update.</p>
<p>[2] This method is optional (starting with SVN rev166495/LLDB-175). While
implementing it in terms of num_children is acceptable, implementors are
encouraged to look for optimized coding alternatives whenever reasonable.</p>
<p>[3] This method is optional (starting with SVN revision 219330). The SBValue
you return here will most likely be a numeric type (int, float, …) as its
value bytes will be used as-if they were the value of the root SBValue proper.
As a shortcut for this, you can inherit from lldb.SBSyntheticValueProvider, and
just define get_value as other methods are defaulted in the superclass as
returning default no-children responses.</p>
<p>If a synthetic child provider supplies a special child named $$dereference$$
then it will be used when evaluating opertaor* and operator-&gt; in the frame
variable command and related SB API functions.</p>
<p>For examples of how synthetic children are created, you are encouraged to look
at examples/synthetic in the LLDB trunk. Please, be aware that the code in
those files (except bitfield/) is legacy code and is not maintained. You may
especially want to begin looking at this example to get a feel for this
feature, as it is a very easy and well commented example.</p>
<p>The design pattern consistently used in synthetic providers shipping with LLDB
is to use the __init__ to store the SBValue instance as a part of self. The
update function is then used to perform the actual initialization. Once a
synthetic children provider is written, one must load it into LLDB before it
can be used. Currently, one can use the LLDB script command to type Python code
interactively, or use the command script import fileName command to load Python
code from a Python module (ordinary rules apply to importing modules this way).
A third option is to type the code for the provider class interactively while
adding it.</p>
<p>For example, let’s pretend we have a class Foo for which a synthetic children
provider class Foo_Provider is available, in a Python module contained in file
~/Foo_Tools.py. The following interaction sets Foo_Provider as a synthetic
children provider in LLDB:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">command</span> <span class="n">script</span> <span class="kn">import</span> <span class="o">~/</span><span class="n">Foo_Tools</span><span class="o">.</span><span class="n">py</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">synthetic</span> <span class="n">add</span> <span class="n">Foo</span> <span class="o">--</span><span class="n">python</span><span class="o">-</span><span class="k">class</span> <span class="nc">Foo_Tools</span><span class="o">.</span><span class="n">Foo_Provider</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">a_foo</span>
<span class="p">(</span><span class="n">Foo</span><span class="p">)</span> <span class="n">a_foo</span> <span class="o">=</span> <span class="p">{</span>
   <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
   <span class="n">y</span> <span class="o">=</span> <span class="s2">&quot;Hello world&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>LLDB has synthetic children providers for a core subset of STL classes, both in
the version provided by libstdcpp and by libcxx, as well as for several
Foundation classes.</p>
<p>Synthetic children extend summary strings by enabling a new special variable:
<code class="docutils literal notranslate"><span class="pre">${svar</span></code>.</p>
<p>This symbol tells LLDB to refer expression paths to the synthetic children
instead of the real ones. For instance,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="o">--</span><span class="n">expand</span> <span class="o">-</span><span class="n">x</span> <span class="s2">&quot;std::vector&lt;&quot;</span> <span class="o">--</span><span class="n">summary</span><span class="o">-</span><span class="n">string</span> <span class="s2">&quot;${svar%#} items&quot;</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">numbers</span>
<span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span> <span class="n">numbers</span> <span class="o">=</span> <span class="mi">4</span> <span class="n">items</span> <span class="p">{</span>
   <span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
   <span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span>
   <span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">123</span>
   <span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1234</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In some cases, if LLDB is unable to use the real object to get a child
specified in an expression path, it will automatically refer to the synthetic
children. While in summaries it is best to always use ${svar to make your
intentions clearer, interactive debugging can benefit from this behavior, as
in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="n">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="n">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span>
</pre></div>
</div>
<p>Unlike many other visualization features, however, the access to synthetic
children only works when using frame variable, and is not supported in
expression:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">expression</span> <span class="n">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">Error</span> <span class="p">[</span><span class="n">IRForTarget</span><span class="p">]:</span> <span class="n">Call</span> <span class="n">to</span> <span class="n">a</span> <span class="n">function</span> <span class="s1">&#39;_ZNSt33vector&lt;int, std::allocator&lt;int&gt; &gt;ixEm&#39;</span> <span class="n">that</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">present</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">target</span>
<span class="n">error</span><span class="p">:</span> <span class="n">Couldn</span><span class="s1">&#39;t convert the expression to DWARF</span>
</pre></div>
</div>
<p>The reason for this is that classes might have an overloaded operator [], or
other special provisions and the expression command chooses to ignore synthetic
children in the interest of equivalency with code you asked to have compiled
from source.</p>
</div>
<div class="section" id="filters">
<h2><a class="toc-backref" href="#id11">Filters</a><a class="headerlink" href="#filters" title="Permalink to this headline">¶</a></h2>
<p>Filters are a solution to the display of complex classes. At times, classes
have many member variables but not all of these are actually necessary for the
user to see.</p>
<p>A filter will solve this issue by only letting the user see those member
variables he cares about. Of course, the equivalent of a filter can be
implemented easily using synthetic children, but a filter lets you get the job
done without having to write Python code.</p>
<p>For instance, if your class Foobar has member variables named A thru Z, but you
only need to see the ones named B, H and Q, you can define a filter:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="nb">filter</span> <span class="n">add</span> <span class="n">Foobar</span> <span class="o">--</span><span class="n">child</span> <span class="n">B</span> <span class="o">--</span><span class="n">child</span> <span class="n">H</span> <span class="o">--</span><span class="n">child</span> <span class="n">Q</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span> <span class="n">a_foobar</span>
<span class="p">(</span><span class="n">Foobar</span><span class="p">)</span> <span class="n">a_foobar</span> <span class="o">=</span> <span class="p">{</span>
   <span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="n">B</span> <span class="o">=</span> <span class="mi">1</span>
   <span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="n">H</span> <span class="o">=</span> <span class="s1">&#39;H&#39;</span>
   <span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="p">)</span> <span class="n">Q</span> <span class="o">=</span> <span class="s2">&quot;Hello world&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="objective-c-dynamic-type-discovery">
<h2><a class="toc-backref" href="#id12">Objective-C Dynamic Type Discovery</a><a class="headerlink" href="#objective-c-dynamic-type-discovery" title="Permalink to this headline">¶</a></h2>
<p>When doing Objective-C development, you may notice that some of your variables
come out as of type id (for instance, items extracted from NSArray). By
default, LLDB will not show you the real type of the object. it can actually
dynamically discover the type of an Objective-C variable, much like the runtime
itself does when invoking a selector. In order to be shown the result of that
discovery that, however, a special option to frame variable or expression is
required: <code class="docutils literal notranslate"><span class="pre">--dynamic-type</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">--dynamic-type</span></code> can have one of three values:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">no-dynamic-values</span></code>: the default, prevents dynamic type discovery</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">no-run-target</span></code>: enables dynamic type discovery as long as running code on
the target is not required</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">run-target</span></code>: enables code execution on the target in order to perform
dynamic type discovery</p></li>
</ul>
<p>If you specify a value of either no-run-target or run-target, LLDB will detect
the dynamic type of your variables and show the appropriate formatters for
them. As an example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(lldb) expr @&quot;Hello&quot;
(NSString *) $0 = 0x00000001048000b0 @&quot;Hello&quot;
(lldb) expr -d no-run @&quot;Hello&quot;
(__NSCFString *) $1 = 0x00000001048000b0 @&quot;Hello&quot;
</pre></div>
</div>
<p>Because LLDB uses a detection algorithm that does not need to invoke any
functions on the target process, no-run-target is enough for this to work.</p>
<p>As a side note, the summary for NSString shown in the example is built right
into LLDB. It was initially implemented through Python (the code is still
available for reference at CFString.py). However, this is out of sync with the
current implementation of the NSString formatter (which is a C++ function
compiled into the LLDB core).</p>
</div>
<div class="section" id="categories">
<h2><a class="toc-backref" href="#id13">Categories</a><a class="headerlink" href="#categories" title="Permalink to this headline">¶</a></h2>
<p>Categories are a way to group related formatters. For instance, LLDB itself
groups the formatters for the libstdc++ types in a category named
gnu-libstdc++. Basically, categories act like containers in which to store
formatters for a same library or OS release.</p>
<p>By default, several categories are created in LLDB:</p>
<ul class="simple">
<li><p>default: this is the category where every formatter ends up, unless another category is specified</p></li>
<li><p>objc: formatters for basic and common Objective-C types that do not specifically depend on macOS</p></li>
<li><p>gnu-libstdc++: formatters for std::string, std::vector, std::list and std::map as implemented by libstdcpp</p></li>
<li><p>libcxx: formatters for std::string, std::vector, std::list and std::map as implemented by libcxx</p></li>
<li><p>system: truly basic types for which a formatter is required</p></li>
<li><p>AppKit: Cocoa classes</p></li>
<li><p>CoreFoundation: CF classes</p></li>
<li><p>CoreGraphics: CG classes</p></li>
<li><p>CoreServices: CS classes</p></li>
<li><p>VectorTypes: compact display for several vector types</p></li>
</ul>
<p>If you want to use a custom category for your formatters, all the type … add
provide a –category (-w) option, that names the category to add the formatter
to. To delete the formatter, you then have to specify the correct category.</p>
<p>Categories can be in one of two states: enabled and disabled. A category is
initially disabled, and can be enabled using the type category enable command.
To disable an enabled category, the command to use is type category disable.</p>
<p>The order in which categories are enabled or disabled is significant, in that
LLDB uses that order when looking for formatters. Therefore, when you enable a
category, it becomes the second one to be searched (after default, which always
stays on top of the list). The default categories are enabled in such a way
that the search order is:</p>
<ul class="simple">
<li><p>default</p></li>
<li><p>objc</p></li>
<li><p>CoreFoundation</p></li>
<li><p>AppKit</p></li>
<li><p>CoreServices</p></li>
<li><p>CoreGraphics</p></li>
<li><p>gnu-libstdc++</p></li>
<li><p>libcxx</p></li>
<li><p>VectorTypes</p></li>
<li><p>system</p></li>
</ul>
<p>As said, gnu-libstdc++ and libcxx contain formatters for C++ STL data types.
system contains formatters for char* and char[], which reflect the behavior of
older versions of LLDB which had built-in formatters for these types. Because
now these are formatters, you can even replace them with your own if so you
wish.</p>
<p>There is no special command to create a category. When you place a formatter in
a category, if that category does not exist, it is automatically created. For
instance,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">summary</span> <span class="n">add</span> <span class="n">Foobar</span> <span class="o">--</span><span class="n">summary</span><span class="o">-</span><span class="n">string</span> <span class="s2">&quot;a foobar&quot;</span> <span class="o">--</span><span class="n">category</span> <span class="n">newcategory</span>
</pre></div>
</div>
<p>automatically creates a (disabled) category named newcategory.</p>
<p>Another way to create a new (empty) category, is to enable it, as in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="nb">type</span> <span class="n">category</span> <span class="n">enable</span> <span class="n">newcategory</span>
</pre></div>
</div>
<p>However, in this case LLDB warns you that enabling an empty category has no
effect. If you add formatters to the category after enabling it, they will be
honored. But an empty category per se does not change the way any type is
displayed. The reason the debugger warns you is that enabling an empty category
might be a typo, and you effectively wanted to enable a similarly-named but
not-empty category.</p>
</div>
<div class="section" id="finding-formatters-101">
<h2><a class="toc-backref" href="#id14">Finding Formatters 101</a><a class="headerlink" href="#finding-formatters-101" title="Permalink to this headline">¶</a></h2>
<p>Searching for a formatter (including formats, starting in SVN rev r192217)
given a variable goes through a rather intricate set of rules. Namely, what
happens is that LLDB starts looking in each enabled category, according to the
order in which they were enabled (latest enabled first). In each category, LLDB
does the following:</p>
<ul class="simple">
<li><p>If there is a formatter for the type of the variable, use it</p></li>
<li><p>If this object is a pointer, and there is a formatter for the pointee type
that does not skip pointers, use it</p></li>
<li><p>If this object is a reference, and there is a formatter for the referred type
that does not skip references, use it</p></li>
<li><p>If this object is an Objective-C class and dynamic types are enabled, look
for a formatter for the dynamic type of the object. If dynamic types are
disabled, or the search failed, look for a formatter for the declared type of
the object</p></li>
<li><p>If this object’s type is a typedef, go through typedef hierarchy (LLDB might
not be able to do this if the compiler has not emitted enough information. If
the required information to traverse typedef hierarchies is missing, type
cascading will not work. The clang compiler, part of the LLVM project, emits
the correct debugging information for LLDB to cascade). If at any level of
the hierarchy there is a valid formatter that can cascade, use it.</p></li>
<li><p>If everything has failed, repeat the above search, looking for regular
expressions instead of exact matches</p></li>
</ul>
<p>If any of those attempts returned a valid formatter to be used, that one is
used, and the search is terminated (without going to look in other categories).
If nothing was found in the current category, the next enabled category is
scanned according to the same algorithm. If there are no more enabled
categories, the search has failed.</p>
<p><strong>Warning</strong>: previous versions of LLDB defined cascading to mean not only going
through typedef chains, but also through inheritance chains. This feature has
been removed since it significantly degrades performance. You need to set up
your formatters for every type in inheritance chains to which you want the
formatter to apply.</p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">LLDB</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Goals &amp; Status</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../status/goals.html">Goals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../status/features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../status/status.html">Status</a></li>
<li class="toctree-l1"><a class="reference internal" href="../status/projects.html">Projects</a></li>
</ul>
<p class="caption"><span class="caption-text">Use &amp; Extension</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="map.html">GDB to LLDB command map</a></li>
<li class="toctree-l1"><a class="reference internal" href="formatting.html">Frame and Thread Format</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Variable Formatting</a></li>
<li class="toctree-l1"><a class="reference internal" href="symbolication.html">Symbolication</a></li>
<li class="toctree-l1"><a class="reference internal" href="symbols.html">Symbols on macOS</a></li>
<li class="toctree-l1"><a class="reference internal" href="python.html">Python Scripting</a></li>
<li class="toctree-l1"><a class="reference internal" href="python-reference.html">Python Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="remote.html">Remote Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="troubleshooting.html">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="architecture.html">Architecture</a></li>
</ul>
<p class="caption"><span class="caption-text">Resources</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../resources/download.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources/source.html">Getting the Sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources/build.html">Build</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources/test.html">Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources/bots.html">Continuous Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources/sbapi.html">The SB API Coding Rules</a></li>
</ul>
<p class="caption"><span class="caption-text">API Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://lldb.llvm.org/python_reference/index.html">Public Python API Reference</a></li>
<li class="toctree-l1"><a class="reference external" href="https://lldb.llvm.org/cpp_reference/namespacelldb.html">Public C++ API Reference</a></li>
<li class="toctree-l1"><a class="reference external" href="https://lldb.llvm.org/cpp_reference/index.html">Private C++ Reference</a></li>
</ul>
<p class="caption"><span class="caption-text">External Links</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="http://llvm.org/viewvc/llvm-project/lldb/trunk/">Source Code</a></li>
<li class="toctree-l1"><a class="reference external" href="https://reviews.llvm.org">Code Reviews</a></li>
<li class="toctree-l1"><a class="reference external" href="https://bugs.llvm.org/">Bug Reports</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="formatting.html" title="previous chapter">Frame and Thread Format</a></li>
      <li>Next: <a href="symbolication.html" title="next chapter">Symbolication</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2007-2019, The LLDB Team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>