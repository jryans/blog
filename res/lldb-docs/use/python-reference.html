
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Python Reference &#8212; The LLDB Debugger</title>
    <link rel="stylesheet" href="../static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../static/lldb.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../static/documentation_options.js"></script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <script type="text/javascript" src="../static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Remote Debugging" href="remote.html" />
    <link rel="prev" title="Python Scripting" href="python.html" />
   
  <link rel="stylesheet" href="../static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="python-reference">
<h1>Python Reference<a class="headerlink" href="#python-reference" title="Permalink to this headline">¶</a></h1>
<p>The entire LLDB API is available as Python functions through a script bridging
interface. This means the LLDB API’s can be used directly from python either
interactively or to build python apps that provide debugger features.</p>
<p>Additionally, Python can be used as a programmatic interface within the lldb
command interpreter (we refer to this for brevity as the embedded interpreter).
Of course, in this context it has full access to the LLDB API - with some
additional conveniences we will call out in the FAQ.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#documentation" id="id1">Documentation</a></p></li>
<li><p><a class="reference internal" href="#embedded-python-interpreter" id="id2">Embedded Python Interpreter</a></p></li>
<li><p><a class="reference internal" href="#running-a-python-script-when-a-breakpoint-gets-hit" id="id3">Running a python script when a breakpoint gets hit</a></p></li>
<li><p><a class="reference internal" href="#using-the-python-api-s-to-create-custom-breakpoints" id="id4">Using the python api’s to create custom breakpoints</a></p></li>
<li><p><a class="reference internal" href="#using-the-python-api-to-create-custom-stepping-logic" id="id5">Using the python API’ to create custom stepping logic</a></p></li>
<li><p><a class="reference internal" href="#create-a-new-lldb-command-using-a-python-function" id="id6">Create a new lldb command using a Python function</a></p></li>
<li><p><a class="reference internal" href="#using-the-lldb-py-module-in-python" id="id7">Using the lldb.py module in Python</a></p></li>
<li><p><a class="reference internal" href="#writing-lldb-frame-recognizers-in-python" id="id8">Writing lldb frame recognizers in Python</a></p></li>
</ul>
</div>
<div class="section" id="documentation">
<h2><a class="toc-backref" href="#id1">Documentation</a><a class="headerlink" href="#documentation" title="Permalink to this headline">¶</a></h2>
<p>The LLDB API is contained in a python module named lldb. A useful resource when
writing Python extensions is the lldb Python classes reference guide.</p>
<p>The documentation is also accessible in an interactive debugger session with
the following command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">script</span> <span class="n">help</span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span>
   <span class="n">Help</span> <span class="n">on</span> <span class="n">package</span> <span class="n">lldb</span><span class="p">:</span>

   <span class="n">NAME</span>
      <span class="n">lldb</span> <span class="o">-</span> <span class="n">The</span> <span class="n">lldb</span> <span class="n">module</span> <span class="n">contains</span> <span class="n">the</span> <span class="n">public</span> <span class="n">APIs</span> <span class="k">for</span> <span class="n">Python</span> <span class="n">binding</span><span class="o">.</span>

   <span class="n">FILE</span>
      <span class="o">/</span><span class="n">System</span><span class="o">/</span><span class="n">Library</span><span class="o">/</span><span class="n">PrivateFrameworks</span><span class="o">/</span><span class="n">LLDB</span><span class="o">.</span><span class="n">framework</span><span class="o">/</span><span class="n">Versions</span><span class="o">/</span><span class="n">A</span><span class="o">/</span><span class="n">Resources</span><span class="o">/</span><span class="n">Python</span><span class="o">/</span><span class="n">lldb</span><span class="o">/</span><span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>

   <span class="n">DESCRIPTION</span>
<span class="o">...</span>
</pre></div>
</div>
<p>You can also get help using a module class name. The full API that is exposed
for that class will be displayed in a man page style window. Below we want to
get help on the lldb.SBFrame class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">script</span> <span class="n">help</span><span class="p">(</span><span class="n">lldb</span><span class="o">.</span><span class="n">SBFrame</span><span class="p">)</span>
   <span class="n">Help</span> <span class="n">on</span> <span class="k">class</span> <span class="nc">SBFrame</span> <span class="ow">in</span> <span class="n">module</span> <span class="n">lldb</span><span class="p">:</span>

   <span class="k">class</span> <span class="nc">SBFrame</span><span class="p">(</span><span class="n">__builtin__</span><span class="o">.</span><span class="n">object</span><span class="p">)</span>
   <span class="o">|</span>  <span class="n">Represents</span> <span class="n">one</span> <span class="n">of</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">frames</span> <span class="n">associated</span> <span class="k">with</span> <span class="n">a</span> <span class="n">thread</span><span class="o">.</span>
   <span class="o">|</span>  <span class="n">SBThread</span> <span class="n">contains</span> <span class="n">SBFrame</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span> <span class="n">For</span> <span class="n">example</span> <span class="p">(</span><span class="kn">from</span> <span class="nn">test</span><span class="o">/</span><span class="n">lldbutil</span><span class="o">.</span><span class="n">py</span><span class="p">),</span>
   <span class="o">|</span>
   <span class="o">|</span>  <span class="k">def</span> <span class="nf">print_stacktrace</span><span class="p">(</span><span class="n">thread</span><span class="p">,</span> <span class="n">string_buffer</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
   <span class="o">|</span>      <span class="s1">&#39;&#39;&#39;Prints a simple stack trace of this thread.&#39;&#39;&#39;</span>
   <span class="o">|</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Or you can get help using any python object, here we use the lldb.process
object which is a global variable in the lldb module which represents the
currently selected process:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">script</span> <span class="n">help</span><span class="p">(</span><span class="n">lldb</span><span class="o">.</span><span class="n">process</span><span class="p">)</span>
   <span class="n">Help</span> <span class="n">on</span> <span class="n">SBProcess</span> <span class="ow">in</span> <span class="n">module</span> <span class="n">lldb</span> <span class="nb">object</span><span class="p">:</span>

   <span class="k">class</span> <span class="nc">SBProcess</span><span class="p">(</span><span class="n">__builtin__</span><span class="o">.</span><span class="n">object</span><span class="p">)</span>
   <span class="o">|</span>  <span class="n">Represents</span> <span class="n">the</span> <span class="n">process</span> <span class="n">associated</span> <span class="k">with</span> <span class="n">the</span> <span class="n">target</span> <span class="n">program</span><span class="o">.</span>
   <span class="o">|</span>
   <span class="o">|</span>  <span class="n">SBProcess</span> <span class="n">supports</span> <span class="n">thread</span> <span class="n">iteration</span><span class="o">.</span> <span class="n">For</span> <span class="n">example</span> <span class="p">(</span><span class="kn">from</span> <span class="nn">test</span><span class="o">/</span><span class="n">lldbutil</span><span class="o">.</span><span class="n">py</span><span class="p">),</span>
   <span class="o">|</span>
   <span class="o">|</span>  <span class="c1"># ==================================================</span>
   <span class="o">|</span>  <span class="c1"># Utility functions related to Threads and Processes</span>
   <span class="o">|</span>  <span class="c1"># ==================================================</span>
   <span class="o">|</span>
<span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="embedded-python-interpreter">
<h2><a class="toc-backref" href="#id2">Embedded Python Interpreter</a><a class="headerlink" href="#embedded-python-interpreter" title="Permalink to this headline">¶</a></h2>
<p>The embedded python interpreter can be accessed in a variety of ways from
within LLDB. The easiest way is to use the lldb command script with no
arguments at the lldb command prompt:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">script</span>
<span class="n">Python</span> <span class="n">Interactive</span> <span class="n">Interpreter</span><span class="o">.</span> <span class="n">To</span> <span class="n">exit</span><span class="p">,</span> <span class="nb">type</span> <span class="s1">&#39;quit()&#39;</span><span class="p">,</span> <span class="s1">&#39;exit()&#39;</span> <span class="ow">or</span> <span class="n">Ctrl</span><span class="o">-</span><span class="n">D</span><span class="o">.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">2</span><span class="o">+</span><span class="mi">3</span>
<span class="mi">5</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">hex</span><span class="p">(</span><span class="mi">12345</span><span class="p">)</span>
<span class="s1">&#39;0x3039&#39;</span>
<span class="o">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>This drops you into the embedded python interpreter. When running under the
script command, lldb sets some convenience variables that give you quick access
to the currently selected entities that characterize the program and debugger
state. In each case, if there is no currently selected entity of the
appropriate type, the variable’s IsValid method will return false. These
variables are:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 17%" />
<col style="width: 68%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Variable</p></td>
<td><p>Type</p></td>
<td><p>Description</p></td>
</tr>
<tr class="row-even"><td><p><strong>lldb.debugger</strong></p></td>
<td><p><strong>lldb.SBDebugger</strong></p></td>
<td><p>Contains the debugger object whose <strong>script</strong> command was invoked.
The <strong>lldb.SBDebugger</strong> object owns the command interpreter
and all the targets in your debug session.  There will always be a
Debugger in the embedded interpreter.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>lldb.target</strong></p></td>
<td><p><strong>lldb.SBTarget</strong></p></td>
<td><p>Contains the currently selected target - for instance the one made with the
<strong>file</strong> or selected by the <strong>target select &lt;target-index&gt;</strong> command.
The <strong>lldb.SBTarget</strong> manages one running process, and all the executable
and debug files for the process.</p></td>
</tr>
<tr class="row-even"><td><p><strong>lldb.process</strong></p></td>
<td><p><strong>lldb.SBProcess</strong></p></td>
<td><p>Contains the process of the currently selected target.
The <strong>lldb.SBProcess</strong> object manages the threads and allows access to
memory for the process.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>lldb.thread</strong></p></td>
<td><p><strong>lldb.SBThread</strong></p></td>
<td><p>Contains the currently selected thread.
The <strong>lldb.SBThread</strong> object manages the stack frames in that thread.
A thread is always selected in the command interpreter when a target stops.
The <strong>thread select &lt;thread-index&gt;</strong> command can be used to change the
currently selected thread.  So as long as you have a stopped process, there will be
some selected thread.</p></td>
</tr>
<tr class="row-even"><td><p><strong>lldb.frame</strong></p></td>
<td><p><strong>lldb.SBFrame</strong></p></td>
<td><p>Contains the currently selected stack frame.
The <strong>lldb.SBFrame</strong> object manage the stack locals and the register set for
that stack.
A stack frame is always selected in the command interpreter when a target stops.
The <strong>frame select &lt;frame-index&gt;</strong> command can be used to change the
currently selected frame.  So as long as you have a stopped process, there will
be some selected frame.</p></td>
</tr>
</tbody>
</table>
<p>While extremely convenient, these variables have a couple caveats that you
should be aware of. First of all, they hold the values of the selected objects
on entry to the embedded interpreter. They do not update as you use the LLDB
API’s to change, for example, the currently selected stack frame or thread.</p>
<p>Moreover, they are only defined and meaningful while in the interactive Python
interpreter. There is no guarantee on their value in any other situation, hence
you should not use them when defining Python formatters, breakpoint scripts and
commands (or any other Python extension point that LLDB provides). As a
rationale for such behavior, consider that lldb can run in a multithreaded
environment, and another thread might call the “script” command, changing the
value out from under you.</p>
<p>To get started with these objects and LLDB scripting, please note that almost
all of the lldb Python objects are able to briefly describe themselves when you
pass them to the Python print function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">script</span>
<span class="n">Python</span> <span class="n">Interactive</span> <span class="n">Interpreter</span><span class="o">.</span> <span class="n">To</span> <span class="n">exit</span><span class="p">,</span> <span class="nb">type</span> <span class="s1">&#39;quit()&#39;</span><span class="p">,</span> <span class="s1">&#39;exit()&#39;</span> <span class="ow">or</span> <span class="n">Ctrl</span><span class="o">-</span><span class="n">D</span><span class="o">.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span> <span class="n">lldb</span><span class="o">.</span><span class="n">debugger</span>
<span class="n">Debugger</span> <span class="p">(</span><span class="n">instance</span><span class="p">:</span> <span class="s2">&quot;debugger_1&quot;</span><span class="p">,</span> <span class="nb">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span> <span class="n">lldb</span><span class="o">.</span><span class="n">target</span>
<span class="n">a</span><span class="o">.</span><span class="n">out</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span> <span class="n">lldb</span><span class="o">.</span><span class="n">process</span>
<span class="n">SBProcess</span><span class="p">:</span> <span class="n">pid</span> <span class="o">=</span> <span class="mi">59289</span><span class="p">,</span> <span class="n">state</span> <span class="o">=</span> <span class="n">stopped</span><span class="p">,</span> <span class="n">threads</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">executable</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">out</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span> <span class="n">lldb</span><span class="o">.</span><span class="n">thread</span>
<span class="n">SBThread</span><span class="p">:</span> <span class="n">tid</span> <span class="o">=</span> <span class="mh">0x1f03</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span> <span class="n">lldb</span><span class="o">.</span><span class="n">frame</span>
<span class="n">frame</span> <span class="c1">#0: 0x0000000100000bb6 a.out main + 54 at main.c:16</span>
</pre></div>
</div>
</div>
<div class="section" id="running-a-python-script-when-a-breakpoint-gets-hit">
<h2><a class="toc-backref" href="#id3">Running a python script when a breakpoint gets hit</a><a class="headerlink" href="#running-a-python-script-when-a-breakpoint-gets-hit" title="Permalink to this headline">¶</a></h2>
<p>One very powerful use of the lldb Python API is to have a python script run
when a breakpoint gets hit. Adding python scripts to breakpoints provides a way
to create complex breakpoint conditions and also allows for smart logging and
data gathering.</p>
<p>When your process hits a breakpoint to which you have attached some python
code, the code is executed as the body of a function which takes three
arguments:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">breakpoint_function_wrapper</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">bp_loc</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
   <span class="c1"># Your code goes here</span>
</pre></div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 7%" />
<col style="width: 17%" />
<col style="width: 76%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Argument</p></td>
<td><p>Type</p></td>
<td><p>Description</p></td>
</tr>
<tr class="row-even"><td><p><strong>frame</strong></p></td>
<td><p><strong>lldb.SBFrame</strong></p></td>
<td><p>The current stack frame where the breakpoint got hit.
The object will always be valid.
This <strong>frame</strong> argument might <em>not</em> match the currently selected stack frame found in the <strong>lldb</strong> module global variable <strong>lldb.frame</strong>.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>bp_loc</strong></p></td>
<td><p><strong>lldb.SBBreakpointLocation</strong></p></td>
<td><p>The breakpoint location that just got hit. Breakpoints are represented by <strong>lldb.SBBreakpoint</strong>
objects. These breakpoint objects can have one or more locations. These locations
are represented by <strong>lldb.SBBreakpointLocation</strong> objects.</p></td>
</tr>
<tr class="row-even"><td><p><strong>dict</strong></p></td>
<td><p><strong>dict</strong></p></td>
<td><p>The python session dictionary as a standard python dictionary object.</p></td>
</tr>
</tbody>
</table>
<p>Optionally, a Python breakpoint command can return a value. Returning False
tells LLDB that you do not want to stop at the breakpoint. Any other return
value (including None or leaving out the return statement altogether) is akin
to telling LLDB to actually stop at the breakpoint. This can be useful in
situations where a breakpoint only needs to stop the process when certain
conditions are met, and you do not want to inspect the program state manually
at every stop and then continue.</p>
<p>An example will show how simple it is to write some python code and attach it
to a breakpoint. The following example will allow you to track the order in
which the functions in a given shared library are first executed during one run
of your program. This is a simple method to gather an order file which can be
used to optimize function placement within a binary for execution locality.</p>
<p>We do this by setting a regular expression breakpoint that will match every
function in the shared library. The regular expression ‘.’ will match any
string that has at least one character in it, so we will use that. This will
result in one lldb.SBBreakpoint object that contains an
lldb.SBBreakpointLocation object for each function. As the breakpoint gets hit,
we use a counter to track the order in which the function at this particular
breakpoint location got hit. Since our code is passed the location that was
hit, we can get the name of the function from the location, disable the
location so we won’t count this function again; then log some info and continue
the process.</p>
<p>Note we also have to initialize our counter, which we do with the simple
one-line version of the script command.</p>
<p>Here is the code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">breakpoint</span> <span class="nb">set</span> <span class="o">--</span><span class="n">func</span><span class="o">-</span><span class="n">regex</span><span class="o">=.</span> <span class="o">--</span><span class="n">shlib</span><span class="o">=</span><span class="n">libfoo</span><span class="o">.</span><span class="n">dylib</span>
<span class="n">Breakpoint</span> <span class="n">created</span><span class="p">:</span> <span class="mi">1</span><span class="p">:</span> <span class="n">regex</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">module</span> <span class="o">=</span> <span class="n">libfoo</span><span class="o">.</span><span class="n">dylib</span><span class="p">,</span> <span class="n">locations</span> <span class="o">=</span> <span class="mi">223</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">script</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">breakpoint</span> <span class="n">command</span> <span class="n">add</span> <span class="o">--</span><span class="n">script</span><span class="o">-</span><span class="nb">type</span> <span class="n">python</span> <span class="mi">1</span>
<span class="n">Enter</span> <span class="n">your</span> <span class="n">Python</span> <span class="n">command</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span> <span class="n">Type</span> <span class="s1">&#39;DONE&#39;</span> <span class="n">to</span> <span class="n">end</span><span class="o">.</span>
<span class="o">&gt;</span> <span class="c1"># Increment our counter.  Since we are in a function, this must be a global python variable</span>
<span class="o">&gt;</span> <span class="k">global</span> <span class="n">counter</span>
<span class="o">&gt;</span> <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="o">&gt;</span> <span class="c1"># Get the name of the function</span>
<span class="o">&gt;</span> <span class="n">name</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">GetFunctionName</span><span class="p">()</span>
<span class="o">&gt;</span> <span class="c1"># Print the order and the function name</span>
<span class="o">&gt;</span> <span class="nb">print</span> <span class="s1">&#39;[</span><span class="si">%i</span><span class="s1">] </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="c1"># Disable the current breakpoint location so it doesn&#39;t get hit again</span>
<span class="o">&gt;</span> <span class="n">bp_loc</span><span class="o">.</span><span class="n">SetEnabled</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="c1"># No need to stop here</span>
<span class="o">&gt;</span> <span class="k">return</span> <span class="kc">False</span>
<span class="o">&gt;</span> <span class="n">DONE</span>
</pre></div>
</div>
<p>The breakpoint command add command above attaches a python script to breakpoint 1. To remove the breakpoint command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">breakpoint</span> <span class="n">command</span> <span class="n">delete</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="section" id="using-the-python-api-s-to-create-custom-breakpoints">
<h2><a class="toc-backref" href="#id4">Using the python api’s to create custom breakpoints</a><a class="headerlink" href="#using-the-python-api-s-to-create-custom-breakpoints" title="Permalink to this headline">¶</a></h2>
<p>Another use of the Python API’s in lldb is to create a custom breakpoint
resolver. This facility was added in r342259.</p>
<p>It allows you to provide the algorithm which will be used in the breakpoint’s
search of the space of the code in a given Target to determine where to set the
breakpoint locations - the actual places where the breakpoint will trigger. To
understand how this works you need to know a little about how lldb handles
breakpoints.</p>
<p>In lldb, a breakpoint is composed of three parts: the Searcher, the Resolver,
and the Stop Options. The Searcher and Resolver cooperate to determine how
breakpoint locations are set and differ between each breakpoint type. Stop
options determine what happens when a location triggers and includes the
commands, conditions, ignore counts, etc. Stop options are common between all
breakpoint types, so for our purposes only the Searcher and Resolver are
relevant.</p>
<p>The Searcher’s job is to traverse in a structured way the code in the current
target. It proceeds from the Target, to search all the Modules in the Target,
in each Module it can recurse into the Compile Units in that module, and within
each Compile Unit it can recurse over the Functions it contains.</p>
<p>The Searcher can be provided with a SearchFilter that it will use to restrict
this search. For instance, if the SearchFilter specifies a list of Modules, the
Searcher will not recurse into Modules that aren’t on the list. When you pass
the -s modulename flag to break set you are creating a Module-based search
filter. When you pass -f filename.c to break set -n you are creating a file
based search filter. If neither of these is specified, the breakpoint will have
a no-op search filter, so all parts of the program are searched and all
locations accepted.</p>
<p>The Resolver has two functions. The most important one is the callback it
provides. This will get called at the appropriate time in the course of the
search. The callback is where the job of adding locations to the breakpoint
gets done.</p>
<p>The other function is specifying to the Searcher at what depth in the above
described recursion it wants to be called. Setting a search depth also provides
a stop for the recursion. For instance, if you request a Module depth search,
then the callback will be called for each Module as it gets added to the
Target, but the searcher will not recurse into the Compile Units in the module.</p>
<p>One other slight sublety is that the depth at which you get called back is not
necessarily the depth at which the the SearchFilter is specified. For instance,
if you are doing symbol searches, it is convenient to use the Module depth for
the search, since symbols are stored in the module. But the SearchFilter might
specify some subset of CompileUnits, so not all the symbols you might find in
each module will pass the search. You don’t need to handle this situation
yourself, since SBBreakpoint::AddLocation will only add locations that pass the
Search Filter. This API returns an SBError to inform you whether your location
was added.</p>
<p>When the breakpoint is originally created, its Searcher will process all the
currently loaded modules. The Searcher will also visit any new modules as they
are added to the target. This happens, for instance, when a new shared library
gets added to the target in the course of running, or on rerunning if any of
the currently loaded modules have been changed. Note, in the latter case, all
the locations set in the old module will get deleted and you will be asked to
recreate them in the new version of the module when your callback gets called
with that module. For this reason, you shouldn’t try to manage the locations
you add to the breakpoint yourself. Note that the Breakpoint takes care of
deduplicating equal addresses in AddLocation, so you shouldn’t need to worry
about that anyway.</p>
<p>At present, when adding a scripted Breakpoint type, you can only provide a
custom Resolver, not a custom SearchFilter.</p>
<p>The custom Resolver is provided as a Python class with the following methods:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 12%" />
<col style="width: 23%" />
<col style="width: 66%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Name</p></td>
<td><p>Arguments</p></td>
<td><p>Description</p></td>
</tr>
<tr class="row-even"><td><p><strong>__init__</strong></p></td>
<td><p><strong>bkpt: lldb.SBBreakpoint</strong>
<strong>extra_args: lldb.SBStructuredData</strong></p></td>
<td><p>This is the constructor for the new Resolver.</p>
<p><strong>bkpt</strong> is the breakpoint owning this Resolver.</p>
<p><strong>extra_args</strong> is an SBStructuredData object that the user can pass in when creating instances of this
breakpoint.  It is not required, but is quite handy.  For instance if you were implementing a breakpoint on some
symbol name, you could write a generic symbol name based Resolver, and then allow the user to pass
in the particular symbol in the extra_args</p>
</td>
</tr>
<tr class="row-odd"><td><p><strong>__callback__</strong></p></td>
<td><p><strong>sym_ctx: lldb.SBSymbolContext</strong></p></td>
<td><p>This is the Resolver callback.
The <strong>sym_ctx</strong> argument will be filled with the current stage
of the search.</p>
<p>For instance, if you asked for a search depth of lldb.eSearchDepthCompUnit, then the
target, module and compile_unit fields of the sym_ctx will be filled.  The callback should look just in the
context passed in <strong>sym_ctx</strong> for new locations.  If the callback finds an address of interest, it
can add it to the breakpoint with the <strong>SBBreakpoint::AddLocation</strong> method, using the breakpoint passed
in to the <strong>__init__</strong> method.</p>
</td>
</tr>
<tr class="row-even"><td><p><strong>__get_depth__</strong></p></td>
<td><p><strong>None</strong></p></td>
<td><p>Specify the depth at which you wish your callback to get called.  The currently supported options are:</p>
<p>lldb.eSearchDepthModule
lldb.eSearchDepthCompUnit
lldb.eSearchDepthFunction</p>
<p>For instance, if you are looking
up symbols, which are stored at the Module level, you will want to get called back module by module.
So you would want to return <strong>lldb.eSearchDepthModule</strong>.  This method is optional.  If not provided the search
will be done at Module depth.</p>
</td>
</tr>
<tr class="row-odd"><td><p><strong>get_short_help</strong></p></td>
<td><p><strong>None</strong></p></td>
<td><p>This is an optional method.  If provided, the returned string will be printed at the beginning of
the description for this breakpoint.</p></td>
</tr>
</tbody>
</table>
<p>To define a new breakpoint command defined by this class from the lldb command
line, use the command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">breakpoint</span> <span class="nb">set</span> <span class="o">-</span><span class="n">P</span> <span class="n">MyModule</span><span class="o">.</span><span class="n">MyResolverClass</span>
</pre></div>
</div>
<p>You can also populate the extra_args SBStructuredData with a dictionary of
key/value pairs with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">breakpoint</span> <span class="nb">set</span> <span class="o">-</span><span class="n">P</span> <span class="n">MyModule</span><span class="o">.</span><span class="n">MyResolverClass</span> <span class="o">-</span><span class="n">k</span> <span class="n">key_1</span> <span class="o">-</span><span class="n">v</span> <span class="n">value_1</span> <span class="o">-</span><span class="n">k</span> <span class="n">key_2</span> <span class="o">-</span><span class="n">v</span> <span class="n">value_2</span>
</pre></div>
</div>
<p>Although you can’t write a scripted SearchFilter, both the command line and the
SB API’s for adding a scripted resolver allow you to specify a SearchFilter
restricted to certain modules or certain compile units. When using the command
line to create the resolver, you can specify a Module specific SearchFilter by
passing the -s ModuleName option - which can be specified multiple times. You
can also specify a SearchFilter restricted to certain compile units by passing
in the -f CompUnitName option. This can also be specified more than once. And
you can mix the two to specify “this comp unit in this module”. So, for
instance,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">breakpoint</span> <span class="nb">set</span> <span class="o">-</span><span class="n">P</span> <span class="n">MyModule</span><span class="o">.</span><span class="n">MyResolverClass</span> <span class="o">-</span><span class="n">s</span> <span class="n">a</span><span class="o">.</span><span class="n">out</span>
</pre></div>
</div>
<p>will use your resolver, but will only recurse into or accept new locations in
the module a.out.</p>
<p>Another option for creating scripted breakpoints is to use the
SBTarget.CreateBreakpointFromScript API. This one has the advantage that you
can pass in an arbitrary SBStructuredData object, so you can create more
complex parametrizations. SBStructuredData has a handy SetFromJSON method which
you can use for this purpose. Your __init__ function gets passed this
SBStructuredData object. This API also allows you to directly provide the list
of Modules and the list of CompileUnits that will make up the SearchFilter. If
you pass in empty lists, the breakpoint will use the default “search
everywhere,accept everything” filter.</p>
</div>
<div class="section" id="using-the-python-api-to-create-custom-stepping-logic">
<h2><a class="toc-backref" href="#id5">Using the python API’ to create custom stepping logic</a><a class="headerlink" href="#using-the-python-api-to-create-custom-stepping-logic" title="Permalink to this headline">¶</a></h2>
<p>A slightly esoteric use of the Python API’s is to construct custom stepping
types. LLDB’s stepping is driven by a stack of “thread plans” and a fairly
simple state machine that runs the plans. You can create a Python class that
works as a thread plan, and responds to the requests the state machine makes to
run its operations.</p>
<p>There is a longer discussion of scripted thread plans and the state machine,
and several interesting examples of their use in:</p>
<p><a class="reference external" href="https://github.com/llvm/llvm-project/blob/master/lldb/examples/python/scripted_step.py">https://github.com/llvm/llvm-project/blob/master/lldb/examples/python/scripted_step.py</a></p>
<p>And for a MUCH fuller discussion of the whole state machine, see:</p>
<p><a class="reference external" href="https://github.com/llvm/llvm-project/blob/master/lldb/include/lldb/Target/ThreadPlan.h">https://github.com/llvm/llvm-project/blob/master/lldb/include/lldb/Target/ThreadPlan.h</a></p>
<p>If you are reading those comments it is useful to know that scripted thread
plans are set to be “MasterPlans”, and not “OkayToDiscard”.</p>
<p>To implement a scripted step, you define a python class that has the following
methods:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 25%" />
<col style="width: 61%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Name</p></td>
<td><p>Arguments</p></td>
<td><p>Description</p></td>
</tr>
<tr class="row-even"><td><p><strong>__init__</strong></p></td>
<td><p><strong>thread_plan: lldb.SBThreadPlan</strong></p></td>
<td><p>This is the underlying SBThreadPlan that is pushed onto the plan stack.
You will want to store this away in an ivar.  Also, if you are going to
use one of the canned thread plans, you can queue it at this point.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>explains_stop</strong></p></td>
<td><p><strong>event: lldb.SBEvent</strong></p></td>
<td><p>Return True if this stop is part of your thread plans logic, false otherwise.</p></td>
</tr>
<tr class="row-even"><td><p><strong>is_stale</strong></p></td>
<td><p><strong>None</strong></p></td>
<td><p>If your plan is no longer relevant (for instance, you were
stepping in a particular stack frame, but some other operation
pushed that frame off the stack) return True and your plan will
get popped.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>should_step</strong></p></td>
<td><p><strong>None</strong></p></td>
<td><p>Return True if you want lldb to instruction step one instruction,
or False to continue till the next breakpoint is hit.</p></td>
</tr>
<tr class="row-even"><td><p><strong>should_stop</strong></p></td>
<td><p><strong>event: lldb.SBEvent</strong></p></td>
<td><p>If your plan wants to stop and return control to the user at this point, return True.
If your plan is done at this point, call SetPlanComplete on your
thread plan instance.
Also, do any work you need here to set up the next stage of stepping.</p></td>
</tr>
</tbody>
</table>
<p>To use this class to implement a step, use the command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">thread</span> <span class="n">step</span><span class="o">-</span><span class="n">scripted</span> <span class="o">-</span><span class="n">C</span> <span class="n">MyModule</span><span class="o">.</span><span class="n">MyStepPlanClass</span>
</pre></div>
</div>
<p>Or use the SBThread.StepUsingScriptedThreadPlan API. The SBThreadPlan passed
into your __init__ function can also push several common plans (step
in/out/over and run-to-address) in front of itself on the stack, which can be
used to compose more complex stepping operations. When you use subsidiary plans
your explains_stop and should_stop methods won’t get called until the
subsidiary plan is done, or the process stops for an event the subsidiary plan
doesn’t explain. For instance, step over plans don’t explain a breakpoint hit
while performing the step-over.</p>
</div>
<div class="section" id="create-a-new-lldb-command-using-a-python-function">
<h2><a class="toc-backref" href="#id6">Create a new lldb command using a Python function</a><a class="headerlink" href="#create-a-new-lldb-command-using-a-python-function" title="Permalink to this headline">¶</a></h2>
<p>Python functions can be used to create new LLDB command interpreter commands,
which will work like all the natively defined lldb commands. This provides a
very flexible and easy way to extend LLDB to meet your debugging requirements.</p>
<p>To write a python function that implements a new LLDB command define the
function to take four arguments as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">command_function</span><span class="p">(</span><span class="n">debugger</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">internal_dict</span><span class="p">):</span>
    <span class="c1"># Your code goes here</span>
</pre></div>
</div>
<p>Optionally, you can also provide a Python docstring, and LLDB will use it when providing help for your command, as in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">command_function</span><span class="p">(</span><span class="n">debugger</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">internal_dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This command takes a lot of options and does many fancy things&quot;&quot;&quot;</span>
    <span class="c1"># Your code goes here</span>
</pre></div>
</div>
<p>Since lldb 3.5.2, LLDB Python commands can also take an SBExecutionContext as an
argument. This is useful in cases where the command’s notion of where to act is
independent of the currently-selected entities in the debugger.</p>
<p>This feature is enabled if the command-implementing function can be recognized
as taking 5 arguments, or a variable number of arguments, and it alters the
signature as such:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">command_function</span><span class="p">(</span><span class="n">debugger</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="n">exe_ctx</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">internal_dict</span><span class="p">):</span>
    <span class="c1"># Your code goes here</span>
</pre></div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 18%" />
<col style="width: 72%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Argument</p></td>
<td><p>Type</p></td>
<td><p>Description</p></td>
</tr>
<tr class="row-even"><td><p><strong>debugger</strong></p></td>
<td><p><strong>lldb.SBDebugger</strong></p></td>
<td><p>The current debugger object.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>command</strong></p></td>
<td><p><strong>python string</strong></p></td>
<td><p>A python string containing all arguments for your command. If you need to chop up the arguments
try using the <strong>shlex</strong> module’s shlex.split(command) to properly extract the
arguments.</p></td>
</tr>
<tr class="row-even"><td><p><strong>exe_ctx</strong></p></td>
<td><p><strong>lldb.SBExecutionContext</strong></p></td>
<td><p>An execution context object carrying around information on the inferior process’ context in which the command is expected to act</p>
<p><em>Optional since lldb 3.5.2, unavailable before</em></p>
</td>
</tr>
<tr class="row-odd"><td><p><strong>result</strong></p></td>
<td><p><strong>lldb.SBCommandReturnObject</strong></p></td>
<td><p>A return object which encapsulates success/failure information for the command and output text
that needs to be printed as a result of the command. The plain Python “print” command also works but
text won’t go in the result by default (it is useful as a temporary logging facility).</p></td>
</tr>
<tr class="row-even"><td><p><strong>internal_dict</strong></p></td>
<td><p><strong>python dict object</strong></p></td>
<td><p>The dictionary for the current embedded script session which contains all variables
and functions.</p></td>
</tr>
</tbody>
</table>
<p>Since lldb 3.7, Python commands can also be implemented by means of a class
which should implement the following interface:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CommandObjectType</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">debugger</span><span class="p">,</span> <span class="n">session_dict</span><span class="p">):</span>
        <span class="n">this</span> <span class="n">call</span> <span class="n">should</span> <span class="n">initialize</span> <span class="n">the</span> <span class="n">command</span> <span class="k">with</span> <span class="n">respect</span> <span class="n">to</span> <span class="n">the</span> <span class="n">command</span> <span class="n">interpreter</span> <span class="k">for</span> <span class="n">the</span> <span class="n">passed</span><span class="o">-</span><span class="ow">in</span> <span class="n">debugger</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">debugger</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="n">exe_ctx</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="n">this</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">actual</span> <span class="n">bulk</span> <span class="n">of</span> <span class="n">the</span> <span class="n">command</span><span class="p">,</span> <span class="n">akin</span> <span class="n">to</span> <span class="n">Python</span> <span class="n">command</span> <span class="n">functions</span>
    <span class="k">def</span> <span class="nf">get_short_help</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">this</span> <span class="n">call</span> <span class="n">should</span> <span class="k">return</span> <span class="n">the</span> <span class="n">short</span> <span class="n">help</span> <span class="n">text</span> <span class="k">for</span> <span class="n">this</span> <span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">get_long_help</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">this</span> <span class="n">call</span> <span class="n">should</span> <span class="k">return</span> <span class="n">the</span> <span class="n">long</span> <span class="n">help</span> <span class="n">text</span> <span class="k">for</span> <span class="n">this</span> <span class="n">command</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>[1] This method is optional.</p>
<p>As a convenience, you can treat the result object as a Python file object, and
say</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span> <span class="o">&gt;&gt;</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;my command does lots of cool stuff&quot;</span>
</pre></div>
</div>
<p>SBCommandReturnObject and SBStream both support this file-like behavior by
providing write() and flush() calls at the Python layer.</p>
<p>One other handy convenience when defining lldb command-line commands is the
command command script import which will import a module specified by file
path, so you don’t have to change your PYTHONPATH for temporary scripts. It
also has another convenience that if your new script module has a function of
the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__lldb_init_module</span><span class="p">(</span><span class="n">debugger</span><span class="p">,</span> <span class="n">internal_dict</span><span class="p">):</span>
    <span class="c1"># Command Initialization code goes here</span>
</pre></div>
</div>
<p>where debugger and internal_dict are as above, that function will get run when
the module is loaded allowing you to add whatever commands you want into the
current debugger. Note that this function will only be run when using the LLDB
command command script import, it will not get run if anyone imports your
module from another module. If you want to always run code when your module is
loaded from LLDB or when loaded via an import statement in python code you can
test the lldb.debugger object, since you imported the module at the top of the
python ls.py module. This test must be in code that isn’t contained inside of
any function or class, just like the standard test for __main__ like all python
modules usually do. Sample code would look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># Create a new debugger instance in your module if your module</span>
    <span class="c1"># can be run from the command line. When we run a script from</span>
    <span class="c1"># the command line, we won&#39;t have any debugger object in</span>
    <span class="c1"># lldb.debugger, so we can just create it if it will be needed</span>
    <span class="n">lldb</span><span class="o">.</span><span class="n">debugger</span> <span class="o">=</span> <span class="n">lldb</span><span class="o">.</span><span class="n">SBDebugger</span><span class="o">.</span><span class="n">Create</span><span class="p">()</span>
<span class="k">elif</span> <span class="n">lldb</span><span class="o">.</span><span class="n">debugger</span><span class="p">:</span>
    <span class="c1"># Module is being run inside the LLDB interpreter</span>
    <span class="n">lldb</span><span class="o">.</span><span class="n">debugger</span><span class="o">.</span><span class="n">HandleCommand</span><span class="p">(</span><span class="s1">&#39;command script add -f ls.ls ls&#39;</span><span class="p">)</span>
    <span class="nb">print</span> <span class="s1">&#39;The &quot;ls&quot; python command has been installed and is ready for use.&#39;</span>
</pre></div>
</div>
<p>Now we can create a module called ls.py in the file ~/ls.py that will implement
a function that can be used by LLDB’s python command code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/python</span>

<span class="kn">import</span> <span class="nn">lldb</span>
<span class="kn">import</span> <span class="nn">commands</span>
<span class="kn">import</span> <span class="nn">optparse</span>
<span class="kn">import</span> <span class="nn">shlex</span>

<span class="k">def</span> <span class="nf">ls</span><span class="p">(</span><span class="n">debugger</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">internal_dict</span><span class="p">):</span>
    <span class="nb">print</span> <span class="o">&gt;&gt;</span><span class="n">result</span><span class="p">,</span> <span class="p">(</span><span class="n">commands</span><span class="o">.</span><span class="n">getoutput</span><span class="p">(</span><span class="s1">&#39;/bin/ls </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">command</span><span class="p">))</span>

<span class="c1"># And the initialization code to add your commands</span>
<span class="k">def</span> <span class="nf">__lldb_init_module</span><span class="p">(</span><span class="n">debugger</span><span class="p">,</span> <span class="n">internal_dict</span><span class="p">):</span>
    <span class="n">debugger</span><span class="o">.</span><span class="n">HandleCommand</span><span class="p">(</span><span class="s1">&#39;command script add -f ls.ls ls&#39;</span><span class="p">)</span>
    <span class="nb">print</span> <span class="s1">&#39;The &quot;ls&quot; python command has been installed and is ready for use.&#39;</span>
</pre></div>
</div>
<p>Now we can load the module into LLDB and use it</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span> <span class="n">lldb</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">command</span> <span class="n">script</span> <span class="kn">import</span> <span class="o">~/</span><span class="n">ls</span><span class="o">.</span><span class="n">py</span>
<span class="n">The</span> <span class="s2">&quot;ls&quot;</span> <span class="n">python</span> <span class="n">command</span> <span class="n">has</span> <span class="n">been</span> <span class="n">installed</span> <span class="ow">and</span> <span class="ow">is</span> <span class="n">ready</span> <span class="k">for</span> <span class="n">use</span><span class="o">.</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">ls</span> <span class="o">-</span><span class="n">l</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span>
<span class="n">total</span> <span class="mi">365848</span>
<span class="o">-</span><span class="n">rw</span><span class="o">-</span><span class="n">r</span><span class="o">--</span><span class="n">r</span><span class="o">--@</span>  <span class="mi">1</span> <span class="n">someuser</span>  <span class="n">wheel</span>         <span class="mi">6148</span> <span class="n">Jan</span> <span class="mi">19</span> <span class="mi">17</span><span class="p">:</span><span class="mi">27</span> <span class="o">.</span><span class="n">DS_Store</span>
<span class="o">-</span><span class="n">rw</span><span class="o">-------</span>   <span class="mi">1</span> <span class="n">someuser</span>  <span class="n">wheel</span>         <span class="mi">7331</span> <span class="n">Jan</span> <span class="mi">19</span> <span class="mi">15</span><span class="p">:</span><span class="mi">37</span> <span class="n">crash</span><span class="o">.</span><span class="n">log</span>
</pre></div>
</div>
<p>A more interesting template has been created in the source repository that can
help you to create lldb command quickly:</p>
<p><a class="reference external" href="https://github.com/llvm/llvm-project/blob/master/lldb/examples/python/cmdtemplate.py">https://github.com/llvm/llvm-project/blob/master/lldb/examples/python/cmdtemplate.py</a></p>
<p>A commonly required facility is being able to create a command that does some
token substitution, and then runs a different debugger command (usually, it
po’es the result of an expression evaluated on its argument). For instance,
given the following program:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#import &lt;Foundation/Foundation.h&gt;</span>
<span class="n">NSString</span><span class="o">*</span>
<span class="n">ModifyString</span><span class="p">(</span><span class="n">NSString</span><span class="o">*</span> <span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
      <span class="k">return</span> <span class="p">[</span><span class="n">src</span> <span class="n">stringByAppendingString</span><span class="p">:</span><span class="o">@</span><span class="s2">&quot;foobar&quot;</span><span class="p">];</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
      <span class="n">NSString</span><span class="o">*</span> <span class="n">aString</span> <span class="o">=</span> <span class="o">@</span><span class="s2">&quot;Hello world&quot;</span><span class="p">;</span>
      <span class="n">NSString</span><span class="o">*</span> <span class="n">anotherString</span> <span class="o">=</span> <span class="o">@</span><span class="s2">&quot;Let&#39;s be friends&quot;</span><span class="p">;</span>
      <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>you may want a pofoo X command, that equates po [ModifyString(X)
capitalizedString]. The following debugger interaction shows how to achieve
that goal:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(lldb) script
Python Interactive Interpreter. To exit, type &#39;quit()&#39;, &#39;exit()&#39; or Ctrl-D.
&gt;&gt;&gt; def pofoo_funct(debugger, command, result, internal_dict):
...   cmd = &quot;po [ModifyString(&quot; + command + &quot;) capitalizedString]&quot;
...   lldb.debugger.HandleCommand(cmd)
...
&gt;&gt;&gt; ^D
(lldb) command script add pofoo -f pofoo_funct
(lldb) pofoo aString
$1 = 0x000000010010aa00 Hello Worldfoobar
(lldb) pofoo anotherString
$2 = 0x000000010010aba0 Let&#39;s Be Friendsfoobar
</pre></div>
</div>
</div>
<div class="section" id="using-the-lldb-py-module-in-python">
<h2><a class="toc-backref" href="#id7">Using the lldb.py module in Python</a><a class="headerlink" href="#using-the-lldb-py-module-in-python" title="Permalink to this headline">¶</a></h2>
<p>LLDB has all of its core code build into a shared library which gets used by
the <cite>lldb</cite> command line application. On macOS this shared library is a
framework: LLDB.framework and on other unix variants the program is a shared
library: lldb.so. LLDB also provides an lldb.py module that contains the
bindings from LLDB into Python. To use the LLDB.framework to create your own
stand-alone python programs, you will need to tell python where to look in
order to find this module. This is done by setting the PYTHONPATH environment
variable, adding a path to the directory that contains the lldb.py python
module. The lldb driver program has an option to report the path to the lldb
module. You can use that to point to correct lldb.py:</p>
<p>For csh and tcsh:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>% setenv PYTHONPATH `lldb -P`
</pre></div>
</div>
<p>For sh and bash:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>% export PYTHONPATH=`lldb -P`
</pre></div>
</div>
<p>Alternately, you can append the LLDB Python directory to the sys.path list
directly in your Python code before importing the lldb module.</p>
<p>Now your python scripts are ready to import the lldb module. Below is a python
script that will launch a program from the current working directory called
“a.out”, set a breakpoint at “main”, and then run and hit the breakpoint, and
print the process, thread and frame objects if the process stopped:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/python</span>

<span class="kn">import</span> <span class="nn">lldb</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">def</span> <span class="nf">disassemble_instructions</span><span class="p">(</span><span class="n">insts</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">insts</span><span class="p">:</span>
        <span class="nb">print</span> <span class="n">i</span>

<span class="c1"># Set the path to the executable to debug</span>
<span class="n">exe</span> <span class="o">=</span> <span class="s2">&quot;./a.out&quot;</span>

<span class="c1"># Create a new debugger instance</span>
<span class="n">debugger</span> <span class="o">=</span> <span class="n">lldb</span><span class="o">.</span><span class="n">SBDebugger</span><span class="o">.</span><span class="n">Create</span><span class="p">()</span>

<span class="c1"># When we step or continue, don&#39;t return from the function until the process</span>
<span class="c1"># stops. Otherwise we would have to handle the process events ourselves which, while doable is</span>
<span class="c1">#a little tricky.  We do this by setting the async mode to false.</span>
<span class="n">debugger</span><span class="o">.</span><span class="n">SetAsync</span> <span class="p">(</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># Create a target from a file and arch</span>
<span class="nb">print</span> <span class="s2">&quot;Creating a target for &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">exe</span>

<span class="n">target</span> <span class="o">=</span> <span class="n">debugger</span><span class="o">.</span><span class="n">CreateTargetWithFileAndArch</span> <span class="p">(</span><span class="n">exe</span><span class="p">,</span> <span class="n">lldb</span><span class="o">.</span><span class="n">LLDB_ARCH_DEFAULT</span><span class="p">)</span>

<span class="k">if</span> <span class="n">target</span><span class="p">:</span>
    <span class="c1"># If the target is valid set a breakpoint at main</span>
    <span class="n">main_bp</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">BreakpointCreateByName</span> <span class="p">(</span><span class="s2">&quot;main&quot;</span><span class="p">,</span> <span class="n">target</span><span class="o">.</span><span class="n">GetExecutable</span><span class="p">()</span><span class="o">.</span><span class="n">GetFilename</span><span class="p">());</span>

    <span class="nb">print</span> <span class="n">main_bp</span>

    <span class="c1"># Launch the process. Since we specified synchronous mode, we won&#39;t return</span>
    <span class="c1"># from this function until we hit the breakpoint at main</span>
    <span class="n">process</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">LaunchSimple</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">())</span>

    <span class="c1"># Make sure the launch went ok</span>
    <span class="k">if</span> <span class="n">process</span><span class="p">:</span>
        <span class="c1"># Print some simple process info</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">GetState</span> <span class="p">()</span>
        <span class="nb">print</span> <span class="n">process</span>
        <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="n">lldb</span><span class="o">.</span><span class="n">eStateStopped</span><span class="p">:</span>
            <span class="c1"># Get the first thread</span>
            <span class="n">thread</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">GetThreadAtIndex</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">thread</span><span class="p">:</span>
                <span class="c1"># Print some simple thread info</span>
                <span class="nb">print</span> <span class="n">thread</span>
                <span class="c1"># Get the first frame</span>
                <span class="n">frame</span> <span class="o">=</span> <span class="n">thread</span><span class="o">.</span><span class="n">GetFrameAtIndex</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">frame</span><span class="p">:</span>
                    <span class="c1"># Print some simple frame info</span>
                    <span class="nb">print</span> <span class="n">frame</span>
                    <span class="n">function</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">GetFunction</span><span class="p">()</span>
                    <span class="c1"># See if we have debug info (a function)</span>
                    <span class="k">if</span> <span class="n">function</span><span class="p">:</span>
                        <span class="c1"># We do have a function, print some info for the function</span>
                        <span class="nb">print</span> <span class="n">function</span>
                        <span class="c1"># Now get all instructions for this function and print them</span>
                        <span class="n">insts</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="n">GetInstructions</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                        <span class="n">disassemble_instructions</span> <span class="p">(</span><span class="n">insts</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># See if we have a symbol in the symbol table for where we stopped</span>
                        <span class="n">symbol</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">();</span>
                        <span class="k">if</span> <span class="n">symbol</span><span class="p">:</span>
                            <span class="c1"># We do have a symbol, print some info for the symbol</span>
                            <span class="nb">print</span> <span class="n">symbol</span>
</pre></div>
</div>
</div>
<div class="section" id="writing-lldb-frame-recognizers-in-python">
<h2><a class="toc-backref" href="#id8">Writing lldb frame recognizers in Python</a><a class="headerlink" href="#writing-lldb-frame-recognizers-in-python" title="Permalink to this headline">¶</a></h2>
<p>Frame recognizers allow for retrieving information about special frames based
on ABI, arguments or other special properties of that frame, even without
source code or debug info. Currently, one use case is to extract function
arguments that would otherwise be unaccesible, or augment existing arguments.</p>
<p>Adding a custom frame recognizer is done by implementing a Python class and
using the ‘frame recognizer add’ command. The Python class should have a
‘get_recognized_arguments’ method and it will receive an argument of type
lldb.SBFrame representing the current frame that we are trying to recognize.
The method should return a (possibly empty) list of lldb.SBValue objects that
represent the recognized arguments.</p>
<p>An example of a recognizer that retrieves the file descriptor values from libc
functions ‘read’, ‘write’ and ‘close’ follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LibcFdRecognizer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">get_recognized_arguments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">frame</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;read&quot;</span><span class="p">,</span> <span class="s2">&quot;write&quot;</span><span class="p">,</span> <span class="s2">&quot;close&quot;</span><span class="p">]:</span>
      <span class="n">fd</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">EvaluateExpression</span><span class="p">(</span><span class="s2">&quot;$arg1&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">unsigned</span>
      <span class="n">value</span> <span class="o">=</span> <span class="n">lldb</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">CreateValueFromExpression</span><span class="p">(</span><span class="s2">&quot;fd&quot;</span><span class="p">,</span> <span class="s2">&quot;(int)</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">fd</span><span class="p">)</span>
      <span class="k">return</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">[]</span>
</pre></div>
</div>
<p>The file containing this implementation can be imported via ‘command script
import’ and then we can register this recognizer with ‘frame recognizer add’.
It’s important to restrict the recognizer to the libc library (which is
libsystem_kernel.dylib on macOS) to avoid matching functions with the same name
in other modules:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">command</span> <span class="n">script</span> <span class="kn">import</span> <span class="nn">...</span><span class="o">/</span><span class="n">fd_recognizer</span><span class="o">.</span><span class="n">py</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">recognizer</span> <span class="n">add</span> <span class="o">-</span><span class="n">l</span> <span class="n">fd_recognizer</span><span class="o">.</span><span class="n">LibcFdRecognizer</span> <span class="o">-</span><span class="n">n</span> <span class="n">read</span> <span class="o">-</span><span class="n">s</span> <span class="n">libsystem_kernel</span><span class="o">.</span><span class="n">dylib</span>
</pre></div>
</div>
<p>When the program is stopped at the beginning of the ‘read’ function in libc, we can view the recognizer arguments in ‘frame variable’:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">b</span> <span class="n">read</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">r</span>
<span class="n">Process</span> <span class="mi">1234</span> <span class="n">stopped</span>
<span class="o">*</span> <span class="n">thread</span> <span class="c1">#1, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 1.3</span>
    <span class="n">frame</span> <span class="c1">#0: 0x00007fff06013ca0 libsystem_kernel.dylib`read</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">frame</span> <span class="n">variable</span>
<span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="n">fd</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">LLDB</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Goals &amp; Status</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../status/goals.html">Goals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../status/features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../status/status.html">Status</a></li>
<li class="toctree-l1"><a class="reference internal" href="../status/projects.html">Projects</a></li>
</ul>
<p class="caption"><span class="caption-text">Use &amp; Extension</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="map.html">GDB to LLDB command map</a></li>
<li class="toctree-l1"><a class="reference internal" href="formatting.html">Frame and Thread Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="variable.html">Variable Formatting</a></li>
<li class="toctree-l1"><a class="reference internal" href="symbolication.html">Symbolication</a></li>
<li class="toctree-l1"><a class="reference internal" href="symbols.html">Symbols on macOS</a></li>
<li class="toctree-l1"><a class="reference internal" href="python.html">Python Scripting</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Python Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="remote.html">Remote Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="troubleshooting.html">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="architecture.html">Architecture</a></li>
</ul>
<p class="caption"><span class="caption-text">Resources</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../resources/download.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources/source.html">Getting the Sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources/build.html">Build</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources/test.html">Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources/bots.html">Continuous Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources/sbapi.html">The SB API Coding Rules</a></li>
</ul>
<p class="caption"><span class="caption-text">API Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://lldb.llvm.org/python_reference/index.html">Public Python API Reference</a></li>
<li class="toctree-l1"><a class="reference external" href="https://lldb.llvm.org/cpp_reference/namespacelldb.html">Public C++ API Reference</a></li>
<li class="toctree-l1"><a class="reference external" href="https://lldb.llvm.org/cpp_reference/index.html">Private C++ Reference</a></li>
</ul>
<p class="caption"><span class="caption-text">External Links</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="http://llvm.org/viewvc/llvm-project/lldb/trunk/">Source Code</a></li>
<li class="toctree-l1"><a class="reference external" href="https://reviews.llvm.org">Code Reviews</a></li>
<li class="toctree-l1"><a class="reference external" href="https://bugs.llvm.org/">Bug Reports</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="python.html" title="previous chapter">Python Scripting</a></li>
      <li>Next: <a href="remote.html" title="next chapter">Remote Debugging</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2007-2019, The LLDB Team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>